<!DOCTYPE html>
<html charset=UTF-8 dir=ltr encoding=UTF-8 itemtype=https://schema.org/WebPage lang=en-US language=English prefix=og:https://ogp.me/ns>
  <head prefix=lapys:https://www.lapys.dev/>
    <!-- Document Metadata -->
    <meta charset="UTF-8"/>
    <meta content="height=device-height, initial-scale=1.0, maximum-scale=1.0, minimal-ui, minimum-scale=1.0, user-scalable=no, width=device-width" name="viewport"/>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>

    <!-- Document Stylesheet -->
    <style media=all type=text/css>@charset "us-ascii";
      /* DOM Elements */
        /* <body> */
        body {
          margin  : 0;
          overflow: hidden
        }

        /* <body>, <html> */
        body, html {
          height: 100%;
          width : 100%
        }

        /* <body>, <input> */
        body, input { font-size: 100% }

        /* <html> */
        html {
          font-size               : 16px;
          line-height             : 1.15;
          -webkit-text-size-adjust: 100%
        }

        /* <input> */
        input {
          margin  : 0;
          overflow: visible
        }

        input[type=button],
        input[type=reset],
        input[type=submit] { -webkit-appearance: button }

        input[type=checkbox],
        input[type=radio] { padding: 0 }
          /* :-moz-focus-inner */
          input[type=button]::-moz-focus-inner,
          input[type=reset]::-moz-focus-inner,
          input[type=submit]::-moz-focus-inner {
            border-style: none;
            padding     : 0
          }

          /* :-moz-focusring */
          input[type=button]:-moz-focusring,
          input[type=reset]:-moz-focusring,
          input[type=submit]:-moz-focusring { outline: 1px dotted ButtonText }
    </style>

    <!-- Document Title -->
    <title> Snake üêç </title>
  </head>

  <body tabindex=-1>
    <canvas id=canvas style="height: 100%; image-rendering: pixelated; width: 100%" tabindex=-1> </canvas>

    <input autocomplete=off max=65 min=1 onchange="BOARD.columnCount = this.value; BOARD.foodMaximumCount = BOARD.size" oninput="BOARD.columnCount = this.value; BOARD.foodMaximumCount = BOARD.size" style="bottom: 3%; font-family: monospace; left : 10%; position: absolute; text-align: center; width: 33.333333%" tabindex=2 type=number step=1 value="15"/>
    <input autocomplete=off max=65 min=1 onchange="BOARD.rowCount    = this.value; BOARD.foodMaximumCount = BOARD.size" oninput="BOARD.rowCount    = this.value; BOARD.foodMaximumCount = BOARD.size" style="bottom: 3%; font-family: monospace; right: 10%; position: absolute; text-align: center; width: 33.333333%" tabindex=2 type=number step=1 value="10"/>
    <input autocomplete=off onblur="this.style.opacity = 0.3" onclick="" onfocus="this.style.opacity = 1.0" onmouseleave="this.style.opacity = 0.3" onmouseover="this.style.opacity = 1.0" style="border-radius: 50px; bottom: 8%; cursor: pointer; font: 125% monospace; height: 50px; left: 0; margin: auto; opacity: 0.3; padding: 0; position: absolute; right: 0; transition: 100ms ease-in; width: 60%" tabindex=1 type=button value="spawn snek üêç"/>

    <!-- Document Script -->
    <script language=javascript type=text/javascript>
      ; try {
        /* Class */
          // Cell
          function Cell(board, column, row) {
            var board  = board;
            var column = column;
            var row    = row;

            // ...
            Object.defineProperty(this, "board",  {configurable: false, enumerable: false, get: function() { return board  }, set: function(object)     { board  = object instanceof Board ? object : owner }});
            Object.defineProperty(this, "column", {configurable: false, enumerable: true,  get: function() { return column }, set: function(coordinate) { column = +coordinate | 0; column *= column > 0    }});
            Object.defineProperty(this, "row",    {configurable: false, enumerable: true,  get: function() { return row    }, set: function(coordinate) { row    = +coordinate | 0; row    *= row    > 0    }});

            if (false === ("object" === typeof board && board instanceof Board))
            throw new TypeError("`Cell`s must be part of a (single) `Board`");

            this.column = arguments.length > 1 ? arguments[1] instanceof Cell ? arguments[1].column : column : 0;
            this.row    = arguments.length > 1 ? arguments[1] instanceof Cell ? arguments[1].row    : row    : 0;

            /* ... */
            Object.preventExtensions(this)
          }
            Cell.prototype = Object.freeze(Object.create(null, {
              board      : {configurable: false, enumerable: false, value: null, writable: false},
              column     : {configurable: false, enumerable: false, value: 0,    writable: false},
              constructor: {configurable: false, enumerable: false, value: Cell, writable: false},
              row        : {configurable: false, enumerable: false, value: 0,    writable: false},

              toString: {configurable: false, enumerable: false, value: function toString() { return "Cell{" + this.row + ", " + this.column + '}'     }, writable: false},
              valueOf : {configurable: false, enumerable: false, value: function valueOf () { return this.column + (this.row * this.board.columnCount) }, writable: false}
            }));

            // Snake Head
            function SnakeHead(board, column, row) {
              return arguments.length > 1 ? arguments[1] instanceof Cell ? new Cell(board, arguments[1]) : new Cell(board, column, row) : new Cell(board);
            }
              SnakeHead.prototype = Cell.prototype;

            function SnakeTail(column, row) {
              return arguments[0] instanceof Cell ? new Cell(null, arguments[0]) : new Cell(null, column, row)
            }
              SnakeTail.prototype = Cell.prototype;

            // Wall
            function Wall(board, column, row) {
              if (false === ("object" === typeof snake && snake instanceof Board))
              throw new TypeError("`Wall`s must be part of a single `Board`");

              return arguments.length > 1 ? arguments[1] instanceof Cell ? new Cell(board, arguments[1]) : new Cell(board, column, row) : new Cell(board)
            }
              Wall.prototype = Cell.prototype;

          // Collection
          function Collection(capacity) {
            var capacity = arguments.length ? +capacity : 0;
            var length   = 0;

            // ...
            for (let index = capacity; index--; ) {
              if (Object.prototype.hasOwnProperty.call(Collection.prototype, index))
              break;

              Object.defineProperty(Collection.prototype, index, {
                configurable: false,
                enumerable  : false,
                get         : function() { return null },
                set         : function(object) {
                  var constructor = "object" === typeof object && null !== object ? object.constructor : null;

                  // ...
                  Object.defineProperty(this, index, {
                    configurable: false,
                    enumerable  : true,
                    get         : function() { return index < this.length ? object : null },
                    set         : function(subobject) {
                      if (index >= this.length || undefined === subobject) return;

                      if (null === subobject) { object = subobject; return }
                      if (null === constructor || subobject instanceof constructor) { constructor = subobject.constructor; object = subobject }
                    }
                  });

                  this[index] = object
                }
              })
            }

            Object.defineProperty(this, "add",    {configurable: false, enumerable: false, value: function add(objects) { if (capacity >= length + arguments.length) { for (var index = 0; index !== arguments.length; ++index) this[length++] = arguments[index]; return true } return false }, writable: false});
            Object.defineProperty(this, "length", {configurable: false, enumerable: false, get: function() { return length }, set: function(count) { length = +count | 0; length = (length > 0) * (capacity < length ? capacity : length) }})
          }
            Collection.prototype = Object.create(null, {
              constructor: {configurable: false, enumerable: false, value: Collection, writable: false},
              length     : {configurable: false, enumerable: false, value: 0,          writable: false},

              add   : {configurable: false, enumerable: false, value: function add   (objects) { /* Do nothing... */                                                                                                                                                                                                            }, writable: false},
              remove: {configurable: false, enumerable: false, value: function remove(objects) { var length = this.length; for (var index = arguments.length; index--; ) { for (var subindex = length; subindex--; ) if (arguments[index] === this[subindex]) { this[subindex] = this[--length]; break } } this.length = length }, writable: false},
              splice: {configurable: false, enumerable: false, value: function splice()        { /* ->> Display like an `Array` in the Chrome Dev console */                                                                                                                                                                    }, writable: false}
            });

          // Color
          function Color(red, green, blue, alpha) {
            var value = arguments.length > 1 ?
              ((+blue  % 0x100) << 0x00) |
              ((+green % 0x100) << 0x08) |
              ((+red   % 0x100) << 0x10) |
              (arguments.length > 3 ? (+alpha % 0x002) << 0x18 : 0x1000000)
            : arguments.length === 1 ? +arguments[0] : 0x0000000;

            // ...
            Object.defineProperty(this, "blue",    {configurable: false, enumerable: true, get: function() { return (value & 0x00000FF) >>> 0x00 }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0x1FFFF00) | ((intensity % 0x100) << 0x00) }});
            Object.defineProperty(this, "green",   {configurable: false, enumerable: true, get: function() { return (value & 0x000FF00) >>> 0x08 }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0x1FF00FF) | ((intensity % 0x100) << 0x08) }});
            Object.defineProperty(this, "red",     {configurable: false, enumerable: true, get: function() { return (value & 0x0FF0000) >>> 0x10 }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0x100FFFF) | ((intensity % 0x100) << 0x10) }});
            Object.defineProperty(this, "alpha",   {configurable: false, enumerable: true, get: function() { return (value & 0x1000000) >>> 0x18 }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0x0FFFFFF) | ((intensity % 0x002) << 0x18) }});
            Object.defineProperty(this, "valueOf", {configurable: false, enumerable: false, value: function valueOf() { return value }, writable: false});

            /* ... */
            Object.preventExtensions(this)
          }
            Color.prototype = Object.freeze(Object.create(null, {
              blue       : {configurable: false, enumerable: true, value: 0x00,  writable: false},
              green      : {configurable: false, enumerable: true, value: 0x00,  writable: false},
              red        : {configurable: false, enumerable: true, value: 0x00,  writable: false},
              alpha      : {configurable: false, enumerable: true, value: 0x00,  writable: false},
              constructor: {configurable: false, enumerable: true, value: Color, writable: false},

              darken  : {configurable: false, enumerable: false, value: function darken  (red, green, blue) { var color = arguments.length === 1 ? new Color(arguments[0]) : new Color(red, green, blue, 0x1); this.blue -= color.blue;                             this.green -= color.green;                              this.red -= color.red;                            return this }, writable: false},
              lighten : {configurable: false, enumerable: false, value: function lighten (red, green, blue) { var color = arguments.length === 1 ? new Color(arguments[0]) : new Color(red, green, blue, 0x1); this.blue  = Math.min(0xFF, color.blue + this.blue); this.green  = Math.min(0xFF, color.green + this.green); this.red  = Math.min(0xFF, color.red + this.red); return this }, writable: false},
              toString: {configurable: false, enumerable: false, value: function toString()                 { return "rgba(" + this.red + ", " + this.green + ", " + this.blue + ", " + this.alpha + ')'                                                                                                                                                                                  }, writable: false},
              valueOf : {configurable: false, enumerable: false, value: function valueOf ()                 { return (this.alpha << 0x18) | (this.blue << 0x00) | (this.green << 0x08) | (this.red << 0x10)                                                                                                                                                                               }, writable: false}
            }));

            Object.defineProperty(Color, "BLACK",   {configurable: false, enumerable: true, value: new Color(0x00, 0x00, 0x00)});
            Object.defineProperty(Color, "BLUE",    {configurable: false, enumerable: true, value: new Color(0x00, 0x00, 0xFF)});
            Object.defineProperty(Color, "CYAN",    {configurable: false, enumerable: true, value: new Color(0x00, 0xFF, 0xFF)});
            Object.defineProperty(Color, "GRAY",    {configurable: false, enumerable: true, value: new Color(0x69, 0x69, 0x69)});
            Object.defineProperty(Color, "GREEN",   {configurable: false, enumerable: true, value: new Color(0x00, 0xFF, 0x00)});
            Object.defineProperty(Color, "GREY",    {configurable: false, enumerable: true, value: new Color(0x69, 0x69, 0x69)});
            Object.defineProperty(Color, "MAGENTA", {configurable: false, enumerable: true, value: new Color(0xFF, 0x00, 0xFF)});
            Object.defineProperty(Color, "RED",     {configurable: false, enumerable: true, value: new Color(0xFF, 0x00, 0x00)});
            Object.defineProperty(Color, "WHITE",   {configurable: false, enumerable: true, value: new Color(0xFF, 0xFF, 0xFF)});
            Object.defineProperty(Color, "YELLOW",  {configurable: false, enumerable: true, value: new Color(0xFF, 0xFF, 0x00)});

        // Food
        function Food(cell, type) {
          var cell = cell;
          var type = type;

          // ...
          Object.defineProperty(this, "cell", {configurable: false, enumerable: true,  get: function() { return cell }, set: function(object) { cell  = "object" === typeof object && (null === object || object instanceof Cell) ? object : cell }});
          Object.defineProperty(this, "type", {configurable: false, enumerable: true,  get: function() { return type }, set: function(option) { for (var name in Food) if (Food[name] === option) { type = option; break }                        }});

          if (false === ("object" === typeof cell && cell instanceof Cell))
          throw new TypeError("`Food`s must be within a (single) `Cell`");

          this.type = Food.APPLE;
          this.type = type;

          /* ... */
          Object.preventExtensions(this)
        }
          Food.prototype = Object.freeze(Object.create(null, {
            cell       : {configurable: false, enumerable: false, value: null,       writable: false},
            constructor: {configurable: false, enumerable: false, value: Food,       writable: false},
            type       : {configurable: false, enumerable: false, value: Food.APPLE, writable: false},

            board : {configurable: false, enumerable: false, get: function() { return null === this.cell ? null : this.cell.board  }, set: function(board)  { if (null !== this.cell) this.cell.board  = board  }},
            column: {configurable: false, enumerable: false, get: function() { return null === this.cell ? null : this.cell.column }, set: function(column) { if (null !== this.cell) this.cell.column = column }},
            row   : {configurable: false, enumerable: false, get: function() { return null === this.cell ? null : this.cell.row    }, set: function(row)    { if (null !== this.cell) this.cell.row    = row    }}
          }));

          Object.defineProperty(Food, "APPLE",       {configurable: false, enumerable: true, value: 0x01, writable: false});
          Object.defineProperty(Food, "BANANA",      {configurable: false, enumerable: true, value: 0x02, writable: false});
          Object.defineProperty(Food, "BLUEBERRIES", {configurable: false, enumerable: true, value: 0x03, writable: false});
          Object.defineProperty(Food, "CHERRIES",    {configurable: false, enumerable: true, value: 0x04, writable: false});
          Object.defineProperty(Food, "COCONUT",     {configurable: false, enumerable: true, value: 0x05, writable: false});
          Object.defineProperty(Food, "GRAPES",      {configurable: false, enumerable: true, value: 0x06, writable: false});
          Object.defineProperty(Food, "KIWI",        {configurable: false, enumerable: true, value: 0x07, writable: false});
          Object.defineProperty(Food, "MANGO",       {configurable: false, enumerable: true, value: 0x08, writable: false});
          Object.defineProperty(Food, "MELON",       {configurable: false, enumerable: true, value: 0x09, writable: false});
          Object.defineProperty(Food, "LEMON",       {configurable: false, enumerable: true, value: 0x0A, writable: false});
          Object.defineProperty(Food, "OLIVE",       {configurable: false, enumerable: true, value: 0x0B, writable: false});
          Object.defineProperty(Food, "PEACH",       {configurable: false, enumerable: true, value: 0x0C, writable: false});
          Object.defineProperty(Food, "PEAR",        {configurable: false, enumerable: true, value: 0x0D, writable: false});
          Object.defineProperty(Food, "PINEAPPLE",   {configurable: false, enumerable: true, value: 0x0E, writable: false});
          Object.defineProperty(Food, "ORANGE",      {configurable: false, enumerable: true, value: 0x0F, writable: false});
          Object.defineProperty(Food, "STRAWBERRY",  {configurable: false, enumerable: true, value: 0x10, writable: false});
          Object.defineProperty(Food, "TANGERINE",   {configurable: false, enumerable: true, value: 0x11, writable: false});
          Object.defineProperty(Food, "TOMATO",      {configurable: false, enumerable: true, value: 0x12, writable: false});
          Object.defineProperty(Food, "WATERMELON",  {configurable: false, enumerable: true, value: 0x13, writable: false});

          Object.defineProperty(Food, "BADGER",   {configurable: false, enumerable: true, value: 0x14, writable: false});
          Object.defineProperty(Food, "CAMEL",    {configurable: false, enumerable: true, value: 0x15, writable: false});
          Object.defineProperty(Food, "CAT",      {configurable: false, enumerable: true, value: 0x16, writable: false});
          Object.defineProperty(Food, "CHIPMUNK", {configurable: false, enumerable: true, value: 0x17, writable: false});
          Object.defineProperty(Food, "COW",      {configurable: false, enumerable: true, value: 0x18, writable: false});
          Object.defineProperty(Food, "DOG",      {configurable: false, enumerable: true, value: 0x19, writable: false});
          Object.defineProperty(Food, "GIRAFFE",  {configurable: false, enumerable: true, value: 0x1A, writable: false});
          Object.defineProperty(Food, "GOAT",     {configurable: false, enumerable: true, value: 0x1B, writable: false});
          Object.defineProperty(Food, "HORSE",    {configurable: false, enumerable: true, value: 0x1C, writable: false});
          Object.defineProperty(Food, "MONKEY",   {configurable: false, enumerable: true, value: 0x1D, writable: false});
          Object.defineProperty(Food, "MOUSE",    {configurable: false, enumerable: true, value: 0x1E, writable: false});
          Object.defineProperty(Food, "PIG",      {configurable: false, enumerable: true, value: 0x1F, writable: false});
          Object.defineProperty(Food, "RABBIT",   {configurable: false, enumerable: true, value: 0x20, writable: false});
          Object.defineProperty(Food, "RACCOON",  {configurable: false, enumerable: true, value: 0x21, writable: false});
          Object.defineProperty(Food, "RAM",      {configurable: false, enumerable: true, value: 0x22, writable: false});
          Object.defineProperty(Food, "RAT",      {configurable: false, enumerable: true, value: 0x23, writable: false});
          Object.defineProperty(Food, "SHEEP",    {configurable: false, enumerable: true, value: 0x24, writable: false});
          Object.defineProperty(Food, "SLOTH",    {configurable: false, enumerable: true, value: 0x25, writable: false});
          Object.defineProperty(Food, "ZEBRA",    {configurable: false, enumerable: true, value: 0x26, writable: false});

          Object.preventExtensions(Food);

        // Snake
        function Snake(head) {
          var head           = head;
          var headColor      = Snake.prototype.headColor;
          var tailColor      = Snake.prototype.tailColor;
          var tailCollection = new Collection();

          // ...
          Object.defineProperty(this, "board",     {configurable: false, enumerable: false, get: function() { return head.board     }, set: function(board)      { head.board = board                                                                                                                                                                                                              }});
          Object.defineProperty(this, "head",      {configurable: false, enumerable: false, get: function() { return head           }, set: function(cell)       { if ("object" !== typeof cell) return; if (null === cell) { head = null; tailCollection = new Collection() } else if (cell instanceof Cell) { cell.owner = this; head = cell; tailCollection = new Collection(cell.board.size) } }});
          Object.defineProperty(this, "headColor", {configurable: false, enumerable: false, get: function() { return headColor      }, set: function(color)      { headColor      = new Color(color)                                                                                                                                                                                               }});
          Object.defineProperty(this, "tail",      {configurable: false, enumerable: false, get: function() { return tailCollection }, set: function(collection) { tailCollection = "object" === typeof collection && collection instanceof Collection ? collection : tailCollection                                                                                                               }});
          Object.defineProperty(this, "tailColor", {configurable: false, enumerable: false, get: function() { return tailColor      }, set: function(color)      { tailColor      = new Color(color)                                                                                                                                                                                               }});

          if (false === ("object" === typeof head && head instanceof Cell))
          throw new TypeError("`Snake`s must have a (single) `Cell` head");

          /* ... */
          Object.preventExtensions(this)
        }
          Snake.prototype = Object.freeze(Object.create(null, {
            board      : {configurable: false, enumerable: false, value: null,             writable: false},
            constructor: {configurable: false, enumerable: false, value: Snake,            writable: false},
            head       : {configurable: false, enumerable: false, value: null,             writable: false},
            headColor  : {configurable: false, enumerable: false, value: Color.GREY,       writable: false},
            tail       : {configurable: false, enumerable: false, value: new Collection(), writable: false},
            tailColor  : {configurable: false, enumerable: false, value: Color.BLACK,      writable: false}
          }));

        // Board
        function Board(context) {
          var BOARD  = this;
          var MEATS  = [Food.BADGER, Food.CAMEL, Food.CAT, Food.CHIPMUNK, Food.COW, Food.DOG, Food.GIRAFFE, Food.GOAT, Food.HORSE, Food.MONKEY, Food.MOUSE, Food.PIG, Food.RABBIT, Food.RACCOON, Food.RAM, Food.RAT, Food.SHEEP, Food.SLOTH, Food.ZEBRA];
          var PLANTS = [Food.APPLE, Food.BANANA, Food.BLUEBERRIES, Food.CHERRIES, Food.COCONUT, Food.GRAPES, Food.KIWI, Food.MANGO, Food.MELON, Food.LEMON, Food.OLIVE, Food.PEACH, Food.PEAR, Food.PINEAPPLE, Food.ORANGE, Food.STRAWBERRY, Food.TANGERINE, Food.TOMATO, Food.WATERMELON];

          var backgroundColor       = Board.prototype.backgroundColor;
          var boardMargin           = Board.prototype.boardMargin;
          var boardPadding          = Board.prototype.boardPadding;
          var boardRadius           = Board.prototype.boardRadius;
          var cellMargin            = Board.prototype.cellMargin;
          var cellRadius            = Board.prototype.cellRadius;
          var columnCount           = Board.prototype.columnCount;
          var foodMaximumCount      = Board.prototype.foodMaximumCount;
          var foodSpawnDelta        = Board.prototype.foodSpawnDelta;
          var foodSpawnMinimumCount = Board.prototype.foodSpawnMinimumCount;
          var foodSpawnTimer        = Board.prototype.foodSpawnTimer;
          var foregroundColor       = Board.prototype.foregroundColor;
          var rowCount              = Board.prototype.rowCount;
          var vegan                 = Board.prototype.vegan;

          var food   = new Collection(0);
          var snakes = new Collection(1);
          var walls  = new Collection(0);

          var canvas            = null;
          var context           = context;
          var snakeMaximumCount = 0;
          var timestamp         = new Date();

          // ...
          function getBoardClientSize() {
            return Math.max(0.0, Math.min(canvas.height, canvas.width) - (boardMargin * 2.0))
          }

          function getCellClientSize(size) {
            return (size - (boardPadding * 2.0) - (boardRadius * 2.0)) / (columnCount > rowCount ? columnCount : rowCount)
          }

          function resize() {
            var recentFood   = food;
            var recentSnakes = snakes;
            var recentWalls  = walls;
            var size         = BOARD.size;
            var snakeCount   = (() => { var count = snakes.length; for (var index = count; index; ) count += snakes[--index].tail.length; return count })();
            var wallCount    = walls.length;

            // ...
            food   = new Collection(Math.min(foodMaximumCount, size - (snakeCount + wallCount)));
            walls  = new Collection(BOARD.size);
            snakes = size > snakeMaximumCount ? new Collection(snakeMaximumCount = size) : snakes;

            for (var index = recentFood  .length; index--; ) { if (columnCount > recentFood  [index].column && rowCount > recentFood  [index].row) void food .add(recentFood [index]) }
            for (var index = recentWalls .length; index--; ) { if (columnCount > recentWalls [index].column && rowCount > recentWalls [index].row) void walls.add(recentWalls[index]) }
            for (var index = recentSnakes.length; index--; ) { if (recentSnakes === snakes) break; void snakes.add(recentSnakes[index]) }
          }

          // ...
          Object.defineProperty(this, "backgroundColor", {configurable: false, enumerable: false, get: function() { return backgroundColor }, set: function(color) { backgroundColor = new Color(color) }});
          Object.defineProperty(this, "foregroundColor", {configurable: false, enumerable: false, get: function() { return foregroundColor }, set: function(color) { foregroundColor = new Color(color) }});

          Object.defineProperty(this, "boardMargin",           {configurable: false, enumerable: false, get: function() { return boardMargin           }, set: function(margin)       { boardMargin           = +margin;           boardMargin          *= boardMargin    > 0                                                                }});
          Object.defineProperty(this, "boardPadding",          {configurable: false, enumerable: false, get: function() { return boardPadding          }, set: function(padding)      { boardPadding          = +padding;          boardPadding         *= boardPadding   > 0                                                                }});
          Object.defineProperty(this, "boardRadius",           {configurable: false, enumerable: false, get: function() { return boardRadius           }, set: function(radius)       { boardRadius           = +radius;           boardRadius          *= boardRadius    > 0                                                                }});
          Object.defineProperty(this, "cellMargin",            {configurable: false, enumerable: false, get: function() { return cellMargin            }, set: function(margin)       { cellMargin            = +margin;           cellMargin           *= cellMargin     > 0                                                                }});
          Object.defineProperty(this, "cellRadius",            {configurable: false, enumerable: false, get: function() { return cellRadius            }, set: function(radius)       { cellRadius            = +radius;           cellRadius           *= cellRadius     > 0                                                                }});
          Object.defineProperty(this, "columnCount",           {configurable: false, enumerable: false, get: function() { return columnCount           }, set: function(count)        { columnCount           = +count        | 0; columnCount          *= columnCount    > 0; this.foodMaximumCount = Math.min(foodMaximumCount, this.size) }});
          Object.defineProperty(this, "foodSpawnDelta",        {configurable: false, enumerable: false, get: function() { return foodSpawnDelta        }, set: function(delta)        { foodSpawnDelta        = +delta        | 0; foodSpawnDelta       *= foodSpawnDelta > 0                                                                }});
          Object.defineProperty(this, "foodSpawnMinimumCount", {configurable: false, enumerable: false, get: function() { return foodSpawnMinimumCount }, set: function(count)        { foodSpawnMinimumCount = +count        | 0; foodSpawnMinimumCount = foodSpawnMinimumCount > 1 ? foodSpawnMinimumCount : 1                             }});
          Object.defineProperty(this, "foodSpawnTimer",        {configurable: false, enumerable: false, get: function() { return foodSpawnTimer        }, set: function(milliseconds) { foodSpawnTimer        = +milliseconds | 0; foodSpawnTimer       *= foodSpawnTimer > 0                                                                }});
          Object.defineProperty(this, "rowCount",              {configurable: false, enumerable: false, get: function() { return rowCount              }, set: function(count)        { rowCount              = +count        | 0; rowCount             *= rowCount       > 0; this.foodMaximumCount = Math.min(foodMaximumCount, this.size) }});
          Object.defineProperty(this, "vegan",                 {configurable: false, enumerable: false, get: function() { return vegan                 }, set: function(option)       { vegan                 = !!option                                                                                                                     }});

          Object.defineProperty(this, "context",          {configurable: false, enumerable: false, get: function() { return context          }, set: function(object) { if ("object" === typeof object && (object instanceof CanvasRenderingContext2D || object instanceof OffscreenCanvasRenderingContext2D)) { canvas = object.canvas; context = object } }});
          Object.defineProperty(this, "foodMaximumCount", {configurable: false, enumerable: false, get: function() { return foodMaximumCount }, set: function(count)  { var recentFoodMaximumCount = foodMaximumCount; foodMaximumCount = +count | 0; foodMaximumCount *= foodMaximumCount > 0; if (foodMaximumCount !== recentFoodMaximumCount) resize()   }});

          Object.defineProperty(this, "boardSize", {configurable: false, enumerable: false, get: function() { return getBoardClientSize()                    }});
          Object.defineProperty(this, "cellSize",  {configurable: false, enumerable: false, get: function() { return getCellClientSize(getBoardClientSize()) }});
          Object.defineProperty(this, "food",      {configurable: false, enumerable: false, get: function() { return food                                    }});
          Object.defineProperty(this, "snakes",    {configurable: false, enumerable: false, get: function() { return snakes                                  }});
          Object.defineProperty(this, "walls",     {configurable: false, enumerable: false, get: function() { return walls                                   }});

          if (false === ("object" === typeof context && (context instanceof CanvasRenderingContext2D || context instanceof OffscreenCanvasRenderingContext2D)))
          throw TypeError("`Board` requires a valid `HTMLCanvasElement` \"2d\" context");

          canvas = context.canvas;
          this.snakes.add(new Snake(new SnakeHead(this, Math.trunc(columnCount / 2), Math.trunc(rowCount / 2))));

          // ...
          requestAnimationFrame(function render() {
            var alias                    = coordinate => coordinate | 0; // ->> reduce non-intentioned anti-aliasing
            var boardSize                = getBoardClientSize();
            var canvasBoundingClientRect = canvas.getBoundingClientRect();

            var boardLeft                    = (canvasBoundingClientRect.width  - boardSize) / 2.0;
            var boardTop                     = (canvasBoundingClientRect.height - boardSize) / 2.0;
            var cellSize                     = getCellClientSize(boardSize);
            var cellSubMargin                = cellMargin < cellSize ? cellMargin : cellSize;
            var contextImageSmoothingEnabled = context.imageSmoothingEnabled;
            var contextImageSmoothingQuality = context.imageSmoothingQuality;
            var foodCount                    = food.length;
            var foodSpawnIncoming            = foodCount < foodSpawnMinimumCount;
            var size                         = BOARD.size;
            var snakeCount                   = (() => { var count = snakes.length; for (var index = count; index; ) count += snakes[--index].tail.length; return count })();
            var wallCount                    = walls.length;

            // Modification > ...
            canvas.height                 = canvasBoundingClientRect.height;
            canvas.width                  = canvasBoundingClientRect.width;
            context.imageSmoothingEnabled = false;
            context.imageSmoothingQuality = "low";

            context.clearRect(0, 0, canvas.width, canvas.height);

            // ... [Board]
            context.fillStyle = backgroundColor;

            context.beginPath();
              context.arc(alias(boardLeft + boardRadius + (boardSize * 0)), alias(boardTop + boardRadius + (boardSize * 0)), alias(boardRadius), Math.PI * 0.0, Math.PI * 2.0);
              context.arc(alias(boardLeft - boardRadius + (boardSize * 1)), alias(boardTop + boardRadius + (boardSize * 0)), alias(boardRadius), Math.PI * 0.0, Math.PI * 2.0);

              context.fill();
            context.closePath();

            context.beginPath();
              context.arc(alias(boardLeft - boardRadius + (boardSize * 1)), alias(boardTop - boardRadius + (boardSize * 1)), boardRadius, Math.PI * 0.0, Math.PI * 2.0);
              context.arc(alias(boardLeft + boardRadius + (boardSize * 0)), alias(boardTop - boardRadius + (boardSize * 1)), boardRadius, Math.PI * 0.0, Math.PI * 2.0);

              context.fill();
            context.closePath();

            context.fillRect(alias(boardLeft - (boardRadius * 0.0) + (boardSize * 0)), alias(boardTop + (boardRadius * 1.0) + (boardSize * 0)), alias(boardRadius * 2.0), alias(boardSize - (boardRadius * 2.0)));
            context.fillRect(alias(boardLeft - (boardRadius * 2.0) + (boardSize * 1)), alias(boardTop + (boardRadius * 1.0) + (boardSize * 0)), alias(boardRadius * 2.0), alias(boardSize - (boardRadius * 2.0)));
            context.fillRect(alias(boardLeft + (boardRadius * 1.0) + (boardSize * 0)), alias(boardTop - (boardRadius * 0.0) + (boardSize * 0)), alias(boardSize - (boardRadius * 2.0)), alias(boardRadius * 2.0));
            context.fillRect(alias(boardLeft + (boardRadius * 1.0) + (boardSize * 0)), alias(boardTop - (boardRadius * 2.0) + (boardSize * 1)), alias(boardSize - (boardRadius * 2.0)), alias(boardRadius * 2.0));

            context.fillRect(alias(boardLeft + (boardRadius * 1.0)), alias(boardTop + (boardRadius * 1.0)), alias(boardSize - (boardRadius * 2.0)), alias(boardSize - (boardRadius * 2.0)));

            // ... [Food]
            foodSpawnIncoming = foodSpawnIncoming || foodSpawnTimer < new Date() - timestamp;
            timestamp         = foodSpawnIncoming ? new Date() : timestamp;

            if (foodSpawnIncoming && foodCount < Math.min(foodMaximumCount, size - (snakeCount + wallCount))) {
              if (foodCount > foodSpawnMinimumCount + foodSpawnDelta)
                food.length = foodSpawnMinimumCount + foodSpawnDelta;

              while (foodCount < foodSpawnMinimumCount + Math.trunc(Math.random() * foodSpawnDelta)) {
                var column = 0;
                var row    = 0;

                // ...
                generate_coordinates:
                while (true) {
                  column = Math.trunc(columnCount * Math.random());
                  row    = Math.trunc(rowCount    * Math.random());

                  // ...
                  for (var index = foodCount; index--; ) {
                    if (column === food[index].column && row === food[index].row)
                    continue generate_coordinates
                  }

                  for (var index = wallCount; index--; ) {
                    if (column === walls[index].column && row === walls[index].row)
                    continue generate_coordinates
                  }

                  for (var index = snakes.length; index--; ) {
                    if (column === snakes[index].head.column && row === snakes[index].head.row)
                    continue generate_coordinates;

                    for (var subindex = snakes[index].tail.length; subindex--; ) {
                      if (column === snakes[index].tail[subindex].column && row === snakes[index].tail[subindex].row)
                      continue generate_coordinates
                    }
                  }

                  break
                }

                if (false === food.add(new Food(new Cell(BOARD, column, row), (vegan ? PLANTS : MEATS)[Math.trunc(Math.random() * (vegan ? PLANTS : MEATS).length)]))) break;
                if (++foodCount === Math.min(foodMaximumCount, size - (snakeCount + wallCount))) break
              }
            }

            // ... [Cell]
            var cellLeft = boardLeft + boardRadius + boardPadding + (cellSubMargin / 2.0) + (((boardSize - (boardPadding * 2.0) - (boardRadius * 2.0)) - (columnCount * cellSize)) / 2.0);
            var cellTop  = boardTop  + boardRadius + boardPadding + (cellSubMargin / 2.0) + (((boardSize - (boardPadding * 2.0) - (boardRadius * 2.0)) - (rowCount    * cellSize)) / 2.0);

            for (var row = rowCount; row--; )
            for (var column = columnCount; column--; ) {
              var cellSubLeft = cellLeft + (column * cellSize);
              var cellSubTop  = cellTop  + (row    * cellSize);
              var cellSubSize = cellSize - cellSubMargin;

              var cellTopLeftRadius     = Math.min(cellSubSize / 2.0, column === 0               && row === 0            ? Math.max(boardRadius, cellRadius) : cellRadius);
              var cellTopRightRadius    = Math.min(cellSubSize / 2.0, column === columnCount - 1 && row === 0            ? Math.max(boardRadius, cellRadius) : cellRadius);
              var cellBottomLeftRadius  = Math.min(cellSubSize / 2.0, column === 0               && row === rowCount - 1 ? Math.max(boardRadius, cellRadius) : cellRadius);
              var cellBottomRightRadius = Math.min(cellSubSize / 2.0, column === columnCount - 1 && row === rowCount - 1 ? Math.max(boardRadius, cellRadius) : cellRadius);

              // ...
              context.fillStyle = (column + row) % 2 ? new Color(foregroundColor).darken(0x19, 0x19, 0x19) : foregroundColor;

              generate_food_color:
              for (var index = food.length; index--; )
              if (column === food[index].column && row === food[index].row) {
                context.fillStyle = new Color(foregroundColor).lighten(0x99, 0x33, 0x00).darken(0x33, 0x33, 0x66);
                break generate_food_color
              }

              generate_wall_color:
              for (var index = walls.length; index--; )
              if (column === walls[index].column && row === walls[index].row) {
                context.fillStyle = new Color(backgroundColor).darken(0x06, 0x06, 0x06);
                break generate_wall_color
              }

              generate_snake_color:
              for (var index = snakes.length; index--; ) {
                for (var subindex = snakes[index].tail.length; subindex--; )
                if (column === snakes[index].tail[subindex].column && row === snakes[index].tail[subindex].row) {
                  context.fillStyle = snakes[index].tailColor;
                  break generate_snake_color
                }

                if (column === snakes[index].head.column && row === snakes[index].head.row) {
                  context.fillStyle = snakes[index].headColor;
                  break generate_snake_color
                }
              }

              context.beginPath();
                context.arc(alias(cellSubLeft + cellTopLeftRadius  + (cellSubSize * 0)), alias(cellSubTop + cellTopLeftRadius  + (cellSubSize * 0)), alias(cellTopLeftRadius),  Math.PI * 0.0, Math.PI * 2.0);
                context.arc(alias(cellSubLeft - cellTopRightRadius + (cellSubSize * 1)), alias(cellSubTop + cellTopRightRadius + (cellSubSize * 0)), alias(cellTopRightRadius), Math.PI * 0.0, Math.PI * 2.0);

                context.fill();
              context.closePath();

              context.beginPath();
                context.arc(alias(cellSubLeft - cellBottomRightRadius + (cellSubSize * 1)), alias(cellSubTop - cellBottomRightRadius + (cellSubSize * 1)), alias(cellBottomRightRadius), Math.PI * 0.0, Math.PI * 2.0);
                context.arc(alias(cellSubLeft + cellBottomLeftRadius  + (cellSubSize * 0)), alias(cellSubTop - cellBottomLeftRadius  + (cellSubSize * 1)), alias(cellBottomLeftRadius),  Math.PI * 0.0, Math.PI * 2.0);

                context.fill();
              context.closePath();

              context.fillRect(alias(cellSubLeft - (Math.max(cellRadius, cellTopLeftRadius)    * 0.0) + (cellSubSize * 0)), alias(cellSubTop + (Math.max(cellRadius, cellTopLeftRadius)    * 1.0) + (cellSubSize * 0)), alias(cellRadius * 2.0), alias(cellSubSize - (cellBottomLeftRadius  + cellTopLeftRadius)));
              context.fillRect(alias(cellSubLeft - (Math.min(cellRadius, cellTopRightRadius)   * 2.0) + (cellSubSize * 1)), alias(cellSubTop + (Math.max(cellRadius, cellTopRightRadius)   * 1.0) + (cellSubSize * 0)), alias(cellRadius * 2.0), alias(cellSubSize - (cellBottomRightRadius + cellTopRightRadius)));
              context.fillRect(alias(cellSubLeft + (Math.max(cellRadius, cellTopLeftRadius)    * 1.0) + (cellSubSize * 0)), alias(cellSubTop - (Math.max(cellRadius, cellTopLeftRadius)    * 0.0) + (cellSubSize * 0)), alias(cellSubSize - (cellTopLeftRadius    + cellTopRightRadius)),    alias(cellRadius * 2.0));
              context.fillRect(alias(cellSubLeft + (Math.max(cellRadius, cellBottomLeftRadius) * 1.0) + (cellSubSize * 0)), alias(cellSubTop - (Math.min(cellRadius, cellBottomLeftRadius) * 2.0) + (cellSubSize * 1)), alias(cellSubSize - (cellBottomLeftRadius + cellBottomRightRadius)), alias(cellRadius * 2.0));

              context.fillRect(alias(cellSubLeft + (cellRadius * 1.0)), alias(cellSubTop + (cellRadius * 1.0)), alias(cellSubSize - (cellRadius * 2.0)), alias(cellSubSize - (cellRadius * 2.0)))
            }

            // Modification > ...
            context.imageSmoothingEnabled = contextImageSmoothingEnabled;
            context.imageSmoothingQuality = contextImageSmoothingQuality;

            /* ... */
            requestAnimationFrame(render)
          });

          /* ... */
          Object.preventExtensions(this)
        }
          Board.prototype = Object.freeze(Object.create(null, {
            backgroundColor      : {configurable: false, enumerable: false, value: Color.GREY,       writable: false},
            boardMargin          : {configurable: false, enumerable: false, value: 0,                writable: false},
            boardPadding         : {configurable: false, enumerable: false, value: 0,                writable: false},
            boardRadius          : {configurable: false, enumerable: false, value: 0,                writable: false},
            boardSize            : {configurable: false, enumerable: false, value: 0,                writable: false},
            cellMargin           : {configurable: false, enumerable: false, value: 1,                writable: false},
            cellRadius           : {configurable: false, enumerable: false, value: 0,                writable: false},
            cellSize             : {configurable: false, enumerable: false, value: 0,                writable: false},
            columnCount          : {configurable: false, enumerable: false, value: 1,                writable: false},
            constructor          : {configurable: false, enumerable: false, value: Board,            writable: false},
            context              : {configurable: false, enumerable: false, value: null,             writable: false},
            food                 : {configurable: false, enumerable: false, value: new Collection(), writable: false},
            foodMaximumCount     : {configurable: false, enumerable: false, value: 1,                writable: false},
            foodSpawnDelta       : {configurable: false, enumerable: false, value: 0,                writable: false},
            foodSpawnMinimumCount: {configurable: false, enumerable: false, value: 1,                writable: false},
            foodSpawnTimer       : {configurable: false, enumerable: false, value: 3000,             writable: false},
            foregroundColor      : {configurable: false, enumerable: false, value: Color.WHITE,      writable: false},
            rowCount             : {configurable: false, enumerable: false, value: 1,                writable: false},
            snakes               : {configurable: false, enumerable: false, value: new Collection(), writable: false},
            vegan                : {configurable: false, enumerable: false, value: true,             writable: false},
            walls                : {configurable: false, enumerable: false, value: new Collection(), writable: false},

            size: {configurable: false, enumerable: false, get: function() { return this.columnCount * this.rowCount }}
          }));

        /* Constant > ... */
        var BOARD = new Board((canvas instanceof HTMLCanvasElement ? canvas : document.createElement("canvas")).getContext("2d", {alpha: true, desynchronized: true}));

        /* Modification > ... */
        BOARD.backgroundColor       = new Color(0x66, 0x66, 0x66);
        BOARD.cellRadius            = 5.0;
        BOARD.columnCount           = 15;
        BOARD.foodMaximumCount      = 3;
        BOARD.foodSpawnDelta        = 2;
        BOARD.foregroundColor       = new Color(0x99, 0x99, 0x99);
        BOARD.rowCount              = 10;
        BOARD.snakes[0].head.column = Math.trunc(BOARD.columnCount / 2);
        BOARD.snakes[0].head.row    = Math.trunc(BOARD.rowCount    / 2);
        BOARD.snakes[0].headColor   = new Color(0x00, 0x96, 0xFF);
        BOARD.snakes[0].tailColor   = new Color(0x00, 0x69, 0xFF);
        BOARD.vegan                 = true;

        /* ... */
        setTimeout(function render() {
          var boardSize = BOARD.boardSize;

          // ...
          BOARD.boardMargin           = boardSize * (3.0025 / 100.0);
          BOARD.boardPadding          = 8;
          BOARD.boardRadius           = boardSize * (3.0050 / 100.0);
          BOARD.cellMargin            = boardSize * (1.0125 / 100.0);
          BOARD.cellRadius            = boardSize * (1.0625 / 100.0);
          BOARD.foodSpawnDelta        = BOARD.snakes.length + 2;
          BOARD.foodSpawnMinimumCount = BOARD.snakes.length + 1;

          /* ... */
          requestAnimationFrame(render)
        }, 1)
      } catch (error) { throw error; try { null() } catch (error) {
        error.message = "Fix your JavaScript! \uD83D\uDC0D";
        throw error
      } };
    </script>
  </body>
</html>
