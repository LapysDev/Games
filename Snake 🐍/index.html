<!DOCTYPE html>
<html charset=UTF-8 dir=ltr encoding=UTF-8 itemtype=https://schema.org/WebPage lang=en-US language=English prefix=og:https://ogp.me/ns>
  <head prefix=lapys:https://www.lapys.dev/>
    <!-- Document Metadata -->
    <meta charset="UTF-8"/>
    <meta content="height=device-height, initial-scale=1.0, maximum-scale=1.0, minimal-ui, minimum-scale=1.0, user-scalable=no, width=device-width" name="viewport"/>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>

    <!-- Document Stylesheet -->
    <style media=all type=text/css>@charset "us-ascii";
      /* DOM Elements */
        /* <body> */
        body {
          margin   : 0;
          overflow : hidden
        }

        /* <body>, <html> */
        body, html {
          height: 100%;
          width : 100%
        }

        /* <body>, <input> */
        body, input { font-size: 100% }

        /* <html> */
        html {
          font-size               : 16px;
          line-height             : 1.15;
          -webkit-text-size-adjust: 100%
        }

        /* <input> */
        input {
          margin  : 0;
          overflow: visible
        }

        input[type=button],
        input[type=reset],
        input[type=submit] { -webkit-appearance: button }

        input[type=checkbox],
        input[type=radio] { padding: 0 }
          /* :-moz-focus-inner */
          input[type=button]::-moz-focus-inner,
          input[type=reset]::-moz-focus-inner,
          input[type=submit]::-moz-focus-inner {
            border-style: none;
            padding     : 0
          }

          /* :-moz-focusring */
          input[type=button]:-moz-focusring,
          input[type=reset]:-moz-focusring,
          input[type=submit]:-moz-focusring { outline: 1px dotted ButtonText }
    </style>

    <!-- Document Title -->
    <title> Snake üêç </title>
  </head>

  <body tabindex=-1>
    <canvas id=canvas style="height: 100%; image-rendering: pixelated; width: 100%" tabindex=-1> </canvas>

    <input autocomplete=off max=65 min=1 onchange="BOARD.columnCount = this.value; BOARD.foodMaximumCount = BOARD.columnCount * BOARD.rowCount" oninput="BOARD.columnCount = this.value; BOARD.foodMaximumCount = BOARD.columnCount * BOARD.rowCount" style="bottom: 3%; font-family: monospace; left : 10%; position: absolute; text-align: center; width: 33.333333%" tabindex=2 type=number step=1 value="15"/>
    <input autocomplete=off max=65 min=1 onchange="BOARD.rowCount    = this.value; BOARD.foodMaximumCount = BOARD.columnCount * BOARD.rowCount" oninput="BOARD.rowCount    = this.value; BOARD.foodMaximumCount = BOARD.columnCount * BOARD.rowCount" style="bottom: 3%; font-family: monospace; right: 10%; position: absolute; text-align: center; width: 33.333333%" tabindex=2 type=number step=1 value="10"/>
    <input autocomplete=off onblur="this.style.opacity = 0.3" onclick="" onfocus="this.style.opacity = 1.0" onmouseleave="this.style.opacity = 0.3" onmouseover="this.style.opacity = 1.0" style="border-radius: 50px; bottom: 8%; cursor: pointer; font: 25px monospace; height: 50px; left: 0; margin: auto; opacity: 0.3; padding: 0; position: absolute; right: 0; transition: 100ms ease-in; width: 60%" tabindex=1 type=button value="spawn snek üêç"/>

    <!-- Document Script -->
    <script language=javascript type=text/javascript>
      ; try {
        /* Class */
          // Cell
          function Cell(board, column, row) {
            var cell          = this;
            var onboardchange = null;

            // ...
            Object.defineProperty(this, "board",         {configurable: false, enumerable: false, get: function() { return board         }, set: function(object)     { if (object instanceof Board) { board = object; if (null !== onboardchange) cell.onboardchange(object) } }});
            Object.defineProperty(this, "column",        {configurable: false, enumerable: true,  get: function() { return column        }, set: function(coordinate) { column        = +coordinate | 0; column *= column > 0                                                   }});
            Object.defineProperty(this, "onboardchange", {configurable: false, enumerable: false, get: function() { return onboardchange }, set: function(handler)    { onboardchange = null === handler || "function" === typeof handler ? handler : onboardchange             }});
            Object.defineProperty(this, "row",           {configurable: false, enumerable: true,  get: function() { return row           }, set: function(coordinate) { row           = +coordinate | 0; row    *= row    > 0                                                   }});

            if (false === ("object" === typeof board && board instanceof Board))
            throw TypeError("`Cells` must be part of a single `Board`");

            this.board         = board;
            this.column        = arguments.length > 1 ? arguments[1] instanceof Cell ? arguments[1].column : column : 0;
            this.onboardchange = onboardchange;
            this.row           = arguments.length > 1 ? arguments[1] instanceof Cell ? arguments[1].row    : row    : 0;

            /* ... */
            Object.preventExtensions(this)
          }
            Cell.prototype = Object.freeze(Object.create(null, {
              board        : {configurable: false, enumerable: false, value: null, writable: false},
              column       : {configurable: false, enumerable: false, value: 0,    writable: false},
              onboardchange: {configurable: false, enumerable: false, value: 0,    writable: false},
              row          : {configurable: false, enumerable: false, value: 0,    writable: false},

              toString: {configurable: false, enumerable: false, value: function toString() { return "Cell{" + this.row + ", " + this.column + '}'      }, writable: false},
              valueOf : {configurable: false, enumerable: false, value: function valueOf () { return this.column + (this.board.columnCount * this.row)  }, writable: false}
            }));

            // Snake (Head, Tail)
            function SnakeHead(board, column, row) { return arguments.length > 1 ? arguments[1] instanceof Cell ? new Cell(board, arguments[1]) : new Cell(board, column, row) : new Cell(board) }
            function SnakeTail(column, row)        { return arguments[0] instanceof Cell ? new Cell(null, arguments[0]) : new Cell(null, column, row) }
              SnakeHead.prototype = Cell.prototype;
              SnakeTail.prototype = Cell.prototype;

          // Collection
          function Collection(capacity) {
            var capacity = arguments.length ? +capacity : 0;
            var length   = 0;

            // ...
            for (let index = capacity; index; )
            if (false === Object.prototype.hasOwnProperty.call(Collection.prototype, --index)) {
              Object.defineProperty(Collection.prototype, index, {
                configurable: false,
                enumerable  : false,
                get         : function() { return null },
                set         : function(object) {
                  if (index < capacity) {
                    var constructor = "object" === typeof object && null !== object ? object.constructor : null;

                    // ...
                    Object.defineProperty(this, index, {
                      configurable: false,
                      enumerable  : true,
                      get         : function() { return object },
                      set         : function(subobject) { if ("object" === typeof subobject) { if (null === subobject) object = subobject; else { constructor = subobject.constructor; object = subobject } } }
                    });

                    this[index] = object
                  }
                }
              })
            }

            Object.defineProperty(this, "add",    {configurable: false, enumerable: false, value: function add(objects) { if (capacity >= length + arguments.length) { for (var index = 0; index !== arguments.length; ++index) this[length++] = arguments[index]; return true } return false }, writable: false});
            Object.defineProperty(this, "length", {configurable: false, enumerable: false, get: function() { return length }, set: function(count) { length = +count | 0; length = (length > 0) * (capacity < length ? capacity : length) }})
          }
            Collection.prototype = Object.create(null, {
              length: {configurable: false, enumerable: false, value: 0, writable: false},

              add   : {configurable: false, enumerable: false, value: function add   (objects) {                                                                                                                                                                                                                   }, writable: false},
              remove: {configurable: false, enumerable: false, value: function remove(objects) { var length = this.length; for (var index = arguments.length; index--; ) for (var subindex = length; subindex; ) { if (arguments[index] === this[subindex]) this[subindex] = this[--length] } this.length = length }, writable: false},
              splice: {configurable: false, enumerable: false, value: function splice()        { /* ->> Display like an `Array` in the Chrome Dev console */                                                                                                                                                       }, writable: false}
            });

          // Color
          function Color(red, green, blue, alpha) {
            var value = arguments.length > 1 ?
              ((+blue  % 0x100) << 0x00) |
              ((+green % 0x100) << 0x08) |
              ((+red   % 0x100) << 0x10) |
              (arguments.length > 3 ? (+alpha % 0x002) << 0x18 : 0x1000000)
            : arguments.length === 1 ? +arguments[0] : 0x0000000;

            // ...
            Object.defineProperty(this, "blue",    {configurable: false, enumerable: true, get: function() { return (value & 0x00000FF) >>> 0x00 }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0x1FFFF00) | ((intensity % 0x100) << 0x00) }});
            Object.defineProperty(this, "green",   {configurable: false, enumerable: true, get: function() { return (value & 0x000FF00) >>> 0x08 }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0x1FF00FF) | ((intensity % 0x100) << 0x08) }});
            Object.defineProperty(this, "red",     {configurable: false, enumerable: true, get: function() { return (value & 0x0FF0000) >>> 0x10 }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0x100FFFF) | ((intensity % 0x100) << 0x10) }});
            Object.defineProperty(this, "alpha",   {configurable: false, enumerable: true, get: function() { return (value & 0x1000000) >>> 0x18 }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0x0FFFFFF) | ((intensity % 0x002) << 0x18) }});
            Object.defineProperty(this, "valueOf", {configurable: false, enumerable: false, value: function valueOf() { return value }, writable: false});

            /* ... */
            Object.preventExtensions(this)
          }
            Color.prototype = Object.freeze(Object.create(null, {
              blue : {configurable: false, enumerable: true,  value: 0, writable: false},
              green: {configurable: false, enumerable: true,  value: 0, writable: false},
              red  : {configurable: false, enumerable: true,  value: 0, writable: false},
              alpha: {configurable: false, enumerable: true,  value: 0, writable: false},

              darken  : {configurable: false, enumerable: false, value: function darken  (red, green, blue) { var color = arguments.length === 1 ? new Color(arguments[0]) : new Color(red, green, blue, 0x1); this.blue -= color.blue;                             this.green -= color.green;                              this.red -= color.red;                            return this }, writable: false},
              lighten : {configurable: false, enumerable: false, value: function lighten (red, green, blue) { var color = arguments.length === 1 ? new Color(arguments[0]) : new Color(red, green, blue, 0x1); this.blue  = Math.min(0xFF, color.blue + this.blue); this.green  = Math.min(0xFF, color.green + this.green); this.red  = Math.min(0xFF, color.red + this.red); return this }, writable: false},
              toString: {configurable: false, enumerable: false, value: function toString()                 { return "rgba(" + this.red + ", " + this.green + ", " + this.blue + ", " + this.alpha + ')'                                                                                                                                                                                  }, writable: false},
              valueOf : {configurable: false, enumerable: false, value: function valueOf ()                 { return 0x000000                                                                                                                                                                                                                                                             }, writable: false}
            }));

            Object.defineProperty(Color, "BLACK",   {configurable: false, enumerable: true, value: new Color(0x00, 0x00, 0x00)});
            Object.defineProperty(Color, "BLUE",    {configurable: false, enumerable: true, value: new Color(0x00, 0x00, 0xFF)});
            Object.defineProperty(Color, "CYAN",    {configurable: false, enumerable: true, value: new Color(0x00, 0xFF, 0xFF)});
            Object.defineProperty(Color, "GREEN",   {configurable: false, enumerable: true, value: new Color(0x00, 0xFF, 0x00)});
            Object.defineProperty(Color, "GRAY",    {configurable: false, enumerable: true, value: new Color(0x69, 0x69, 0x69)});
            Object.defineProperty(Color, "GREY",    {configurable: false, enumerable: true, value: new Color(0x69, 0x69, 0x69)});
            Object.defineProperty(Color, "MAGENTA", {configurable: false, enumerable: true, value: new Color(0xFF, 0x00, 0xFF)});
            Object.defineProperty(Color, "RED",     {configurable: false, enumerable: true, value: new Color(0xFF, 0x00, 0x00)});
            Object.defineProperty(Color, "WHITE",   {configurable: false, enumerable: true, value: new Color(0xFF, 0xFF, 0xFF)});
            Object.defineProperty(Color, "YELLOW",  {configurable: false, enumerable: true, value: new Color(0xFF, 0xFF, 0x00)});

        // Food
        function Food(cell, type) {
          Object.defineProperty(this, "cell", {configurable: false, enumerable: true,  get: function() { return cell }, set: function(object) { cell  = "object" === typeof object && (null === object || object instanceof Cell) ? object : cell }});
          Object.defineProperty(this, "type", {configurable: false, enumerable: true,  get: function() { return type }, set: function(option) { for (var name in Food) if (Food[name] === option) type = option }});

          this.cell = "object" === typeof cell && (null === cell || cell instanceof Cell) ? cell : null;
          this.type = Food.APPLE;
          this.type = type;

          /* ... */
          Object.preventExtensions(this)
        }
          Food.prototype = Object.freeze(Object.create(null, {
            cell: {configurable: false, enumerable: false, value: null,       writable: false},
            type: {configurable: false, enumerable: false, value: Food.APPLE, writable: false},

            board : {configurable: false, enumerable: false, get: function() { return null === this.cell ? null : this.cell.board  }, set: function(board)  { if (null !== this.cell) this.cell.board  = board  }},
            column: {configurable: false, enumerable: false, get: function() { return null === this.cell ? null : this.cell.column }, set: function(column) { if (null !== this.cell) this.cell.column = column }},
            row   : {configurable: false, enumerable: false, get: function() { return null === this.cell ? null : this.cell.row    }, set: function(row)    { if (null !== this.cell) this.cell.row    = row    }},
          }));

          Object.defineProperty(Food, "BADGER",   {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "CAMEL",    {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "CAT",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "CHIPMUNK", {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "COW",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "DOG",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "GIRAFFE",  {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "GOAT",     {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "HORSE",    {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "MONKEY",   {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "MOUSE",    {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "PIG",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "RABBIT",   {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "RACCOON",  {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "RAM",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "RAT",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "SHEEP",    {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "SLOTH",    {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "ZEBRA",    {configurable: false, enumerable: true, value: Object.create(null), writable: false});

          Object.defineProperty(Food, "APPLE",       {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "BANANA",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "BLUEBERRIES", {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "CHERRIES",    {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "COCONUT",     {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "GRAPES",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "KIWI",        {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "MANGO",       {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "MELON",       {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "LEMON",       {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "OLIVE",       {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "PEACH",       {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "PEAR",        {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "PINEAPPLE",   {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "ORANGE",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "STRAWBERRY",  {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "TANGERINE",   {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "TOMATO",      {configurable: false, enumerable: true, value: Object.create(null), writable: false});
          Object.defineProperty(Food, "WATERMELON",  {configurable: false, enumerable: true, value: Object.create(null), writable: false});

          Object.preventExtensions(Food);

        // Snake
        function Snake(head) {
          var snake = this;

          var headColor      = Snake.prototype.headColor;
          var tailColor      = Snake.prototype.tailColor;
          var tailCollection = new Collection();

          // ...
          function reform() {
            snake.tail = new Collection(this.board.size)
          }

          // ...
          Object.defineProperty(this, "head", {
            configurable: false,
            enumerable  : false,
            get         : function() { return head },
            set         : function(object) {
              if ("object" === typeof object) {
                if (null === object) { tailCollection = new Collection(); if (head instanceof Cell && head.onboardchange === reform) { head.onboardchange = null } head = object }
                else if (object instanceof Cell) { tailCollection = new Collection(object.board.size); object.onboardchange = reform; head = object }
              }
            }
          });

          Object.defineProperty(this, "headColor", {configurable: false, enumerable: false, get: function() { return headColor      }, set: function(color)      { headColor      = new Color(color)                                                                                 }});
          Object.defineProperty(this, "tail",      {configurable: false, enumerable: false, get: function() { return tailCollection }, set: function(collection) { tailCollection = "object" === typeof collection && collection instanceof Collection ? collection : tailCollection }});
          Object.defineProperty(this, "tailColor", {configurable: false, enumerable: false, get: function() { return tailColor      }, set: function(color)      { tailColor      = new Color(color)                                                                                 }});

          this.head = "object" === typeof head && (null === head || head instanceof Cell) ? head : null;

          /* ... */
          Object.preventExtensions(this)
        }
          Snake.prototype = Object.freeze(Object.create(null, {
            head     : {configurable: false, enumerable: false, value: null,             writable: false},
            headColor: {configurable: false, enumerable: false, value: Color.GREY,       writable: false},
            tail     : {configurable: false, enumerable: false, value: new Collection(), writable: false},
            tailColor: {configurable: false, enumerable: false, value: Color.BLACK,      writable: false}
          }));

        // Board
        function Board(context) {
          var board           = this;
          var carnivorousFood = [Food.BADGER, Food.CAMEL, Food.CAT, Food.CHIPMUNK, Food.COW, Food.DOG, Food.GIRAFFE, Food.GOAT, Food.HORSE, Food.MONKEY, Food.MOUSE, Food.PIG, Food.RABBIT, Food.RACCOON, Food.RAM, Food.RAT, Food.SHEEP, Food.SLOTH, Food.ZEBRA];
          var herbivorousFood = [Food.APPLE, Food.BANANA, Food.BLUEBERRIES, Food.CHERRIES, Food.COCONUT, Food.GRAPES, Food.KIWI, Food.MANGO, Food.MELON, Food.LEMON, Food.OLIVE, Food.PEACH, Food.PEAR, Food.PINEAPPLE, Food.ORANGE, Food.STRAWBERRY, Food.TANGERINE, Food.TOMATO, Food.WATERMELON];

          var backgroundColor       = Board.prototype.backgroundColor;
          var boardMargin           = Board.prototype.boardMargin;
          var boardPadding          = Board.prototype.boardPadding;
          var boardRadius           = Board.prototype.boardRadius;
          var cellMargin            = Board.prototype.cellMargin;
          var cellRadius            = Board.prototype.cellRadius;
          var columnCount           = Board.prototype.columnCount;
          var foodMaximumCount      = Board.prototype.foodMaximumCount;
          var foodSpawnDelta        = Board.prototype.foodSpawnDelta;
          var foodSpawnMinimumCount = Board.prototype.foodSpawnMinimumCount;
          var foodSpawnTimer        = Board.prototype.foodSpawnTimer;
          var foregroundColor       = Board.prototype.foregroundColor;
          var rowCount              = Board.prototype.rowCount;
          var snakeMaximumCount     = 0;
          var timestamp             = new Date();
          var vegan                 = Board.prototype.vegan;

          var food   = new Collection();
          var snakes = new Collection(1);
          var walls  = new Collection();

          // ...
          function resize() {
            var recentFood   = food;
            var recentSnakes = snakes;
            var recentWalls  = walls;

            // ...
            food  = new Collection(foodMaximumCount);
            walls = new Collection(board.size);

            for (var index = recentFood .length; index--; ) { if (columnCount >= recentFood [index].column && rowCount >= recentFood [index].row) food .add(recentFood [index]) }
            for (var index = recentWalls.length; index--; ) { if (columnCount >= recentWalls[index].column && rowCount >= recentWalls[index].row) walls.add(recentWalls[index]) }

            if (board.size > snakeMaximumCount) {
              snakes = new Collection(snakeMaximumCount = board.size);
              for (var index = recentSnakes.length; index; ) snakes.add(recentSnakes[--index])
            }
          }

          // ...
          if (false === ("object" === typeof context && (context instanceof CanvasRenderingContext2D || context instanceof OffscreenCanvasRenderingContext2D)))
          throw TypeError("`Board` requires a valid `HTMLCanvasElement` \"2d\" context");

          Object.defineProperty(this, "backgroundColor",       {configurable: false, enumerable: false, get: function() { return backgroundColor       }, set: function(color)        { backgroundColor       = new Color(color)                                                                                                                                     }});
          Object.defineProperty(this, "boardMargin",           {configurable: false, enumerable: false, get: function() { return boardMargin           }, set: function(margin)       { boardMargin           = +margin;           boardMargin          *= boardMargin    > 0                                                                                        }});
          Object.defineProperty(this, "boardPadding",          {configurable: false, enumerable: false, get: function() { return boardPadding          }, set: function(padding)      { boardPadding          = +padding;          boardPadding         *= boardPadding   > 0                                                                                        }});
          Object.defineProperty(this, "boardRadius",           {configurable: false, enumerable: false, get: function() { return boardRadius           }, set: function(radius)       { boardRadius           = +radius;           boardRadius          *= boardRadius    > 0                                                                                        }});
          Object.defineProperty(this, "cellMargin",            {configurable: false, enumerable: false, get: function() { return cellMargin            }, set: function(margin)       { cellMargin            = +margin;           cellMargin           *= cellMargin     > 0                                                                                        }});
          Object.defineProperty(this, "cellRadius",            {configurable: false, enumerable: false, get: function() { return cellRadius            }, set: function(radius)       { cellRadius            = +radius;           cellRadius           *= cellRadius     > 0                                                                                        }});
          Object.defineProperty(this, "columnCount",           {configurable: false, enumerable: false, get: function() { return columnCount           }, set: function(count)        { columnCount           = +count        | 0; columnCount          *= columnCount    > 0; if (foodMaximumCount > board.size) board.foodMaximumCount = board.size                }});
          Object.defineProperty(this, "context",               {configurable: false, enumerable: false, get: function() { return context               }, set: function(object)       { context               = "object" === typeof object && (object instanceof CanvasRenderingContext2D || object instanceof OffscreenCanvasRenderingContext2D) ? object : context }});
          Object.defineProperty(this, "foodMaximumCount",      {configurable: false, enumerable: false, get: function() { return foodMaximumCount      }, set: function(count)        { foodMaximumCount      = +count        | 0; foodMaximumCount     *= foodMaximumCount > 0; resize()                                                                            }});
          Object.defineProperty(this, "foodSpawnDelta",        {configurable: false, enumerable: false, get: function() { return foodSpawnDelta        }, set: function(delta)        { foodSpawnDelta        = +delta        | 0; foodSpawnDelta       *= foodSpawnDelta > 0                                                                                        }});
          Object.defineProperty(this, "foodSpawnMinimumCount", {configurable: false, enumerable: false, get: function() { return foodSpawnMinimumCount }, set: function(count)        { foodSpawnMinimumCount = +count        | 0; foodSpawnMinimumCount = foodSpawnMinimumCount > 1 ? foodSpawnMinimumCount : 1                                                     }});
          Object.defineProperty(this, "foodSpawnTimer",        {configurable: false, enumerable: false, get: function() { return foodSpawnTimer        }, set: function(milliseconds) { foodSpawnTimer        = +milliseconds | 0; foodSpawnTimer       *= foodSpawnTimer > 0                                                                                        }});
          Object.defineProperty(this, "foregroundColor",       {configurable: false, enumerable: false, get: function() { return foregroundColor       }, set: function(color)        { foregroundColor       = new Color(color)                                                                                                                                     }});
          Object.defineProperty(this, "rowCount",              {configurable: false, enumerable: false, get: function() { return rowCount              }, set: function(count)        { rowCount              = +count        | 0; rowCount             *= rowCount       > 0; if (foodMaximumCount > board.size) board.foodMaximumCount = board.size                }});
          Object.defineProperty(this, "vegan",                 {configurable: false, enumerable: false, get: function() { return vegan                 }, set: function(option)       { vegan                 = !!option                                                                                                                                             }});

          Object.defineProperty(this, "boardSize", {configurable: false, enumerable: false, get: function() { var boardSize = context.canvas.height < context.canvas.width ? context.canvas.height : context.canvas.width; return boardSize > (boardMargin * 2.0) ? boardSize - (boardMargin * 2.0) : 0.0 }});
          Object.defineProperty(this, "cellSize",  {configurable: false, enumerable: false, get: function() { return (board.boardSize - (boardPadding * 2.0) - (boardRadius * 2.0)) / (columnCount > rowCount ? columnCount : rowCount)                                                                   }});
          Object.defineProperty(this, "food",      {configurable: false, enumerable: false, get: function() { return food                                                                                                                                                                                 }});
          Object.defineProperty(this, "snakes",    {configurable: false, enumerable: false, get: function() { return snakes                                                                                                                                                                               }});
          Object.defineProperty(this, "walls",     {configurable: false, enumerable: false, get: function() { return walls                                                                                                                                                                                }});

          this.context = context;

          /* ... */
          Object.preventExtensions(this);

          this.snakes.add(new Snake(new Cell(this, Math.trunc(columnCount / 2), Math.trunc(rowCount / 2))));

          requestAnimationFrame(function render() {
            var wallCount     = 0;
            var snakeCount    = 0;
            var foodSpawn     = food.length < foodSpawnMinimumCount;
            var cellSize      = board.cellSize;
            var cellSubMargin = cellMargin < cellSize ? cellMargin : cellSize;
            var canvas        = context.canvas;
            var boardSize     = board.boardSize;
            var boardLeft     = (canvas.getBoundingClientRect().width  - boardSize) / 2.0;
            var boardTop      = (canvas.getBoundingClientRect().height - boardSize) / 2.0;

            // ...
            canvas.height                 = canvas.getBoundingClientRect().height;
            canvas.width                  = canvas.getBoundingClientRect().width;
            context.imageSmoothingEnabled = false;
            context.imageSmoothingQuality = "low";

            context.clearRect(0, 0, canvas.width, canvas.height);

            // ... [Board]
            context.fillStyle = backgroundColor;

            context.beginPath();
              context.arc(boardLeft + boardRadius + (boardSize * 0), boardTop + boardRadius + (boardSize * 0), boardRadius, Math.PI * 0.0, Math.PI * 2.0);
              context.arc(boardLeft - boardRadius + (boardSize * 1), boardTop + boardRadius + (boardSize * 0), boardRadius, Math.PI * 0.0, Math.PI * 2.0);

              context.fill();
            context.closePath();

            context.beginPath();
              context.arc(boardLeft - boardRadius + (boardSize * 1), boardTop - boardRadius + (boardSize * 1), boardRadius, Math.PI * 0.0, Math.PI * 2.0);
              context.arc(boardLeft + boardRadius + (boardSize * 0), boardTop - boardRadius + (boardSize * 1), boardRadius, Math.PI * 0.0, Math.PI * 2.0);

              context.fill();
            context.closePath();

            context.fillRect(boardLeft - (boardRadius * 0.0) + (boardSize * 0), boardTop + (boardRadius * 1.0) + (boardSize * 0), boardRadius * 2.0, boardSize - (boardRadius * 2.0));
            context.fillRect(boardLeft - (boardRadius * 2.0) + (boardSize * 1), boardTop + (boardRadius * 1.0) + (boardSize * 0), boardRadius * 2.0, boardSize - (boardRadius * 2.0));
            context.fillRect(boardLeft + (boardRadius * 1.0) + (boardSize * 0), boardTop - (boardRadius * 0.0) + (boardSize * 0), boardSize - (boardRadius * 2.0), boardRadius * 2.0);
            context.fillRect(boardLeft + (boardRadius * 1.0) + (boardSize * 0), boardTop - (boardRadius * 2.0) + (boardSize * 1), boardSize - (boardRadius * 2.0), boardRadius * 2.0);

            context.fillRect(boardLeft + (boardRadius * 1.0), boardTop + (boardRadius * 1.0), boardSize - (boardRadius * 2.0), boardSize - (boardRadius * 2.0));

            context.fillStyle = "rgba(0, 0, 0, 0.175)";

            context.beginPath();
              context.arc(boardLeft + (boardSize / 2.0), boardTop + (boardSize / 2.0), boardSize * 0.333333, Math.PI * 0.0, Math.PI * 2.0);
              context.fill();
            context.closePath();

            // ... [Food]
            for (var index = board.snakes.length; index--; )
            snakeCount += board.snakes[index].tail.length + (null !== board.snakes[index].head);

            if (foodSpawnTimer < new Date() - timestamp) {
              foodSpawn = true;
              timestamp = new Date()
            }

            if (foodSpawn && food.length < Math.min(foodMaximumCount, board.size - (snakeCount + wallCount))) {
              if (food.length > foodSpawnMinimumCount + foodSpawnDelta)
              food.length = foodSpawnMinimumCount + foodSpawnDelta;

              while (food.length < foodSpawnMinimumCount + Math.trunc(Math.random() * foodSpawnDelta)) {
                var column      = 0;
                var unavailable = false;
                var row         = 0;

                // ...
                generate_coordinates:
                for (var recentColumn = column, recentRow = row; ; ) {
                  column = Math.trunc(columnCount * Math.random());
                  row    = Math.trunc(rowCount    * Math.random());

                  if (column === recentColumn && row === recentRow) {
                    unavailable = true; // ->> ¬Ø\_(„ÉÑ)_/¬Ø
                    break
                  }

                  for (var index = food.length; index--; ) {
                    if (column === food[index].column && row === food[index].row)
                    continue generate_coordinates
                  }

                  for (var index = snakes.length; index--; ) {
                    if (null !== snakes[index].head) {
                      if (column === snakes[index].head.column && row === snakes[index].head.row)
                      continue generate_coordinates
                    }

                    for (var subindex = snakes[index].tail.length; subindex--; ) {
                      if (column === snakes[index].tail[subindex].column && row === snakes[index].tail[subindex].row)
                      continue generate_coordinates
                    }
                  }

                  break
                }

                if (false === unavailable && false === food.add(new Food(new Cell(board, column, row), (vegan ? herbivorousFood : carnivorousFood)[Math.trunc(Math.random() * (vegan ? herbivorousFood : carnivorousFood).length)])))
                break
              }
            }

            // ... [Cell]
            var cellLeft = boardLeft + boardRadius + boardPadding + (cellSubMargin / 2.0) + (((boardSize - (boardPadding * 2.0) - (boardRadius * 2.0)) - (columnCount * cellSize)) / 2.0);
            var cellTop  = boardTop  + boardRadius + boardPadding + (cellSubMargin / 2.0) + (((boardSize - (boardPadding * 2.0) - (boardRadius * 2.0)) - (rowCount    * cellSize)) / 2.0);

            for (var row = rowCount; row--; )
            for (var column = columnCount; column--; ) {
              var cellSubLeft = cellLeft + (column * cellSize);
              var cellSubTop  = cellTop  + (row    * cellSize);
              var cellSubSize = cellSize - cellSubMargin;

              var cellTopLeftRadius     = Math.min(cellSubSize / 2.0, column === 0               && row === 0            ? Math.max(boardRadius, cellRadius) : cellRadius);
              var cellTopRightRadius    = Math.min(cellSubSize / 2.0, column === columnCount - 1 && row === 0            ? Math.max(boardRadius, cellRadius) : cellRadius);
              var cellBottomLeftRadius  = Math.min(cellSubSize / 2.0, column === 0               && row === rowCount - 1 ? Math.max(boardRadius, cellRadius) : cellRadius);
              var cellBottomRightRadius = Math.min(cellSubSize / 2.0, column === columnCount - 1 && row === rowCount - 1 ? Math.max(boardRadius, cellRadius) : cellRadius);

              // ...
              context.fillStyle = (column + row) % 2 ? new Color(foregroundColor).darken(0x19, 0x19, 0x19) : foregroundColor;

              for (var index = food.length; index--; ) {
                if (column === food[index].column && row === food[index].row)
                context.fillStyle = new Color(foregroundColor).lighten(0x99, 0x33, 0x00).darken(0x33, 0x33, 0x66)
              }

              for (var index = snakes.length; index--; ) {
                for (var subindex = snakes[index].tail.length; subindex--; ) {
                  if (column === snakes[index].tail[subindex].column && row === snakes[index].tail[subindex].row)
                  context.fillStyle = snakes[index].tailColor
                }

                if (null !== snakes[index].head) {
                  if (column === snakes[index].head.column && row === snakes[index].head.row)
                  context.fillStyle = snakes[index].headColor
                }
              }

              context.beginPath();
                context.arc(cellSubLeft + cellTopLeftRadius  + (cellSubSize * 0), cellSubTop + cellTopLeftRadius  + (cellSubSize * 0), cellTopLeftRadius,  Math.PI * 0.0, Math.PI * 2.0);
                context.arc(cellSubLeft - cellTopRightRadius + (cellSubSize * 1), cellSubTop + cellTopRightRadius + (cellSubSize * 0), cellTopRightRadius, Math.PI * 0.0, Math.PI * 2.0);

                context.fill();
              context.closePath();

              context.beginPath();
                context.arc(cellSubLeft - cellBottomRightRadius + (cellSubSize * 1), cellSubTop - cellBottomRightRadius + (cellSubSize * 1), cellBottomRightRadius, Math.PI * 0.0, Math.PI * 2.0);
                context.arc(cellSubLeft + cellBottomLeftRadius  + (cellSubSize * 0), cellSubTop - cellBottomLeftRadius  + (cellSubSize * 1), cellBottomLeftRadius,  Math.PI * 0.0, Math.PI * 2.0);

                context.fill();
              context.closePath();

              context.fillRect(cellSubLeft - (Math.max(cellRadius, cellTopLeftRadius) * 0.0) + (cellSubSize * 0), cellSubTop + (Math.max(cellRadius, cellTopLeftRadius) * 1.0) + (cellSubSize * 0), cellRadius * 2.0, cellSubSize - (cellBottomLeftRadius + cellTopLeftRadius));
              context.fillRect(cellSubLeft - (Math.min(cellRadius, cellTopRightRadius) * 2.0) + (cellSubSize * 1), cellSubTop + (Math.max(cellRadius, cellTopRightRadius) * 1.0) + (cellSubSize * 0), cellRadius * 2.0, cellSubSize - (cellBottomRightRadius + cellTopRightRadius));
              context.fillRect(cellSubLeft + (Math.max(cellRadius, cellTopLeftRadius) * 1.0) + (cellSubSize * 0), cellSubTop - (Math.max(cellRadius, cellTopLeftRadius) * 0.0) + (cellSubSize * 0), cellSubSize - (cellTopLeftRadius + cellTopRightRadius), cellRadius * 2.0);
              context.fillRect(cellSubLeft + (Math.max(cellRadius, cellBottomLeftRadius) * 1.0) + (cellSubSize * 0), cellSubTop - (Math.min(cellRadius, cellBottomLeftRadius) * 2.0) + (cellSubSize * 1), cellSubSize - (cellBottomLeftRadius + cellBottomRightRadius), cellRadius * 2.0);

              context.fillRect(cellSubLeft + (cellRadius * 1.0), cellSubTop + (cellRadius * 1.0), cellSubSize - (cellRadius * 2.0), cellSubSize - (cellRadius * 2.0))
            }

            /* ... */
            requestAnimationFrame(render)
          })
        }
          Board.prototype = Object.freeze(Object.create(null, {
            backgroundColor      : {configurable: false, enumerable: false, value: Color.GREY,       writable: false},
            boardMargin          : {configurable: false, enumerable: false, value: 0,                writable: false},
            boardPadding         : {configurable: false, enumerable: false, value: 0,                writable: false},
            boardRadius          : {configurable: false, enumerable: false, value: 0,                writable: false},
            boardSize            : {configurable: false, enumerable: false, value: 0,                writable: false},
            cellMargin           : {configurable: false, enumerable: false, value: 1,                writable: false},
            cellRadius           : {configurable: false, enumerable: false, value: 0,                writable: false},
            cellSize             : {configurable: false, enumerable: false, value: 0,                writable: false},
            columnCount          : {configurable: false, enumerable: false, value: 1,                writable: false},
            context              : {configurable: false, enumerable: false, value: null,             writable: false},
            food                 : {configurable: false, enumerable: false, value: new Collection(), writable: false},
            foodMaximumCount     : {configurable: false, enumerable: false, value: 1,                writable: false},
            foodSpawnDelta       : {configurable: false, enumerable: false, value: 0,                writable: false},
            foodSpawnMinimumCount: {configurable: false, enumerable: false, value: 1,                writable: false},
            foodSpawnTimer       : {configurable: false, enumerable: false, value: 3000,             writable: false},
            foregroundColor      : {configurable: false, enumerable: false, value: Color.WHITE,      writable: false},
            rowCount             : {configurable: false, enumerable: false, value: 1,                writable: false},
            snakes               : {configurable: false, enumerable: false, value: new Collection(), writable: false},
            vegan                : {configurable: false, enumerable: false, value: true,             writable: false},
            walls                : {configurable: false, enumerable: false, value: new Collection(), writable: false},

            size: {configurable: false, enumerable: false, get: function() { return this.columnCount * this.rowCount }}
          }));

        /* Constant > ... */
        var BOARD = new Board((canvas instanceof HTMLCanvasElement ? canvas : document.createElement("canvas")).getContext("2d", {alpha: true, desynchronized: true}));

        /* Modification > ... */
        BOARD.backgroundColor       = new Color(0x66, 0x66, 0x66);
        BOARD.cellRadius            = 5.0;
        BOARD.columnCount           = 15;
        BOARD.foodMaximumCount      = 3;
        BOARD.foodSpawnDelta        = 2;
        BOARD.foregroundColor       = new Color(0x99, 0x99, 0x99);
        BOARD.rowCount              = 10;
        BOARD.snakes[0].head.column = Math.trunc(BOARD.columnCount / 2);
        BOARD.snakes[0].head.row    = Math.trunc(BOARD.rowCount    / 2);
        BOARD.snakes[0].headColor   = new Color(0x00, 0x96, 0xFF);
        BOARD.snakes[0].tailColor   = new Color(0x00, 0x69, 0xFF);
        BOARD.vegan                 = true;

        /* ... */
        setTimeout(function render() {
          var boardSize = BOARD.boardSize;

          // ...
          BOARD.boardMargin           = boardSize * (3.0025 / 100.0);
          BOARD.boardPadding          = 8;
          BOARD.boardRadius           = boardSize * (3.0050 / 100.0);
          BOARD.cellMargin            = boardSize * (1.0125 / 100.0);
          BOARD.cellRadius            = boardSize * (1.0625 / 100.0);
          BOARD.foodSpawnDelta        = BOARD.snakes.length + 2;
          BOARD.foodSpawnMinimumCount = BOARD.snakes.length + 1;

          /* ... */
          requestAnimationFrame(render)
        }, 1)
      } catch (error) { try { null() } catch (error) {
        error.message = "Fix your JavaScript! \uD83D\uDC0D";
        throw error
      } };
    </script>
  </body>
</html>
