<!DOCTYPE html>
<html charset=UTF-8 dir=ltr encoding=UTF-8 itemtype=https://schema.org/WebPage lang=en-US language=English prefix=og:https://ogp.me/ns>
  <head prefix=lapys:https://www.lapys.dev/>
    <!-- Document Metadata -->
    <meta charset="UTF-8"/>
    <meta content="height=device-height, initial-scale=1.0, maximum-scale=1.0, minimal-ui, minimum-scale=1.0, user-scalable=no, width=device-width" name="viewport"/>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>

    <!-- Document Stylesheet -->
    <style media=all type=text/css>@charset "us-ascii";
      /* DOM Elements */
        /* <body> */
        body {
          margin  : 0;
          overflow: hidden
        }

        /* <body>, <html> */
        body, html {
          height: 100%;
          width : 100%
        }

        /* <body>, <input> */
        body, input { font-size: 100% }

        /* <html> */
        html {
          font-size               : 16px;
          line-height             : 1.15;
          -webkit-text-size-adjust: 100%
        }

        /* <input> */
        input {
          margin  : 0;
          overflow: visible
        }

        input[type=button],
        input[type=reset],
        input[type=submit] { -webkit-appearance: button }

        input[type=checkbox],
        input[type=radio] { padding: 0 }
          /* :-moz-focus-inner */
          input[type=button]::-moz-focus-inner,
          input[type=reset]::-moz-focus-inner,
          input[type=submit]::-moz-focus-inner {
            border-style: none;
            padding     : 0
          }

          /* :-moz-focusring */
          input[type=button]:-moz-focusring,
          input[type=reset]:-moz-focusring,
          input[type=submit]:-moz-focusring { outline: 1px dotted ButtonText }
    </style>

    <!-- Document Title -->
    <title> Snake üêç </title>
  </head>

  <body tabindex=-1>
    <canvas id=canvas style="height: 100%; image-rendering: pixelated; width: 100%" tabindex=-1> </canvas>

    <input autocomplete=off max=65 min=1 onchange="BOARD.columnCount = this.value; BOARD.foodMaximumCount = BOARD.size" oninput="BOARD.columnCount = this.value; BOARD.foodMaximumCount = BOARD.size" style="bottom: 3%; font-family: monospace; left : 10%; position: absolute; text-align: center; width: 33.333333%" tabindex=2 type=number step=1 value="15"/>
    <input autocomplete=off max=65 min=1 onchange="BOARD.rowCount    = this.value; BOARD.foodMaximumCount = BOARD.size" oninput="BOARD.rowCount    = this.value; BOARD.foodMaximumCount = BOARD.size" style="bottom: 3%; font-family: monospace; right: 10%; position: absolute; text-align: center; width: 33.333333%" tabindex=2 type=number step=1 value="10"/>
    <input autocomplete=off onblur="this.style.opacity = 0.3" onclick=BOARD.spawn() onfocus="this.style.opacity = 1.0" onmouseleave="this.style.opacity = 0.3" onmouseover="this.style.opacity = 1.0" style="border-radius: 50px; bottom: 8%; cursor: pointer; font: 125% monospace; height: 50px; left: 0; margin: auto; opacity: 0.3; padding: 0; position: absolute; right: 0; transition: 100ms ease-in; width: 60%" tabindex=1 type=button value="spawn snek üêç"/>

    <!-- Document Script -->
    <script language=javascript type=text/javascript>
      ; try {
        /* Class */
          // Cell
          function Cell(board, column, row) {
            var board  = board;
            var column = column;
            var row    = row;

            // ...
            Object.defineProperty(this, "board",  {configurable: false, enumerable: false, get: function() { return board  }, set: function(object)     { board  = object instanceof Board ? object : owner }});
            Object.defineProperty(this, "column", {configurable: false, enumerable: true,  get: function() { return column }, set: function(coordinate) { column = +coordinate | 0; column *= column > 0    }});
            Object.defineProperty(this, "row",    {configurable: false, enumerable: true,  get: function() { return row    }, set: function(coordinate) { row    = +coordinate | 0; row    *= row    > 0    }});

            if (false === ("object" === typeof board && board instanceof Board))
            throw new TypeError("`Cell`s must be part of a (single) `Board`");

            // ...
            if (arguments.length <= 1)
              this.column = this.row = 0;

            else {
              if (false === arguments[1] instanceof Cell) { this.column = column; this.row = row }
              else { var cell = arguments[1]; this.column = cell.column; this.row = cell.row }
            }
            // this.column = arguments.length > 1 ? arguments[1] instanceof Cell ? (console.log(arguments.length), arguments[1].column) : column : 0;
            // this.row    = arguments.length > 1 ? arguments[1] instanceof Cell ? (console.log(arguments.length), arguments[1].row)    : row    : 0;

            /* ... */
            Object.preventExtensions(this)
          }
            Cell.prototype = Object.freeze(Object.create(null, {
              board      : {configurable: false, enumerable: false, value: null, writable: false},
              column     : {configurable: false, enumerable: false, value: 0,    writable: false},
              constructor: {configurable: false, enumerable: false, value: Cell, writable: false},
              row        : {configurable: false, enumerable: false, value: 0,    writable: false},

              toString: {configurable: false, enumerable: false, value: function toString() { return "Cell{" + this.row + ", " + this.column + '}'     }, writable: false},
              valueOf : {configurable: false, enumerable: false, value: function valueOf () { return this.column + (this.row * this.board.columnCount) }, writable: false}
            }));

            // Snake Head
            function SnakeHead(board, column, row) {
              return arguments.length > 1 ? arguments[1] instanceof Cell ? new Cell(board, arguments[1]) : new Cell(board, column, row) : new Cell(board);
            }
              SnakeHead.prototype = Cell.prototype;

            function SnakeTail(column, row) {
              return arguments[0] instanceof Cell ? new Cell(null, arguments[0]) : new Cell(null, column, row)
            }
              SnakeTail.prototype = Cell.prototype;

            // Wall
            function Wall(board, column, row) {
              if (false === ("object" === typeof board && board instanceof Board))
              throw new TypeError("`Wall`s must be part of a single `Board`");

              return new Cell(board, column, row)
            }
              Wall.prototype = Cell.prototype;

          // Collection
          function Collection(capacity) {
            var capacity = arguments.length ? +capacity : 0;
            var length   = 0;

            // ...
            for (let index = capacity; index--; ) {
              if (Object.prototype.hasOwnProperty.call(Collection.prototype, index))
              break;

              Object.defineProperty(Collection.prototype, index, {
                configurable: false,
                enumerable  : false,
                get         : function() { return null },
                set         : function(object) {
                  var constructor = "object" === typeof object && null !== object ? object.constructor : null;

                  // ...
                  Object.defineProperty(this, index, {
                    configurable: false,
                    enumerable  : true,
                    get         : function() { return index < this.length ? object : null },
                    set         : function(subobject) {
                      if (index >= this.length || undefined === subobject) return;

                      if (null === subobject) { object = subobject; return }
                      if (null === constructor || subobject instanceof constructor) { constructor = subobject.constructor; object = subobject }
                    }
                  });

                  this[index] = object
                }
              })
            }

            Object.defineProperty(this, "add",    {configurable: false, enumerable: false, value: function add(objects) { if (capacity >= length + arguments.length) { for (var index = 0; index !== arguments.length; ++index) this[length++] = arguments[index]; return true } return false }, writable: false});
            Object.defineProperty(this, "length", {configurable: false, enumerable: false, get: function() { return length }, set: function(count) { length = +count | 0; length = (length > 0) * (capacity < length ? capacity : length) }})
          }
            Collection.prototype = Object.create(null, {
              constructor: {configurable: false, enumerable: false, value: Collection, writable: false},
              length     : {configurable: false, enumerable: false, value: 0,          writable: false},

              add   : {configurable: false, enumerable: false, value: function add   (objects) { /* Do nothing... */                                                                                                                                                                                                            }, writable: false},
              remove: {configurable: false, enumerable: false, value: function remove(objects) { var length = this.length; for (var index = arguments.length; index--; ) { for (var subindex = length; subindex--; ) if (arguments[index] === this[subindex]) { this[subindex] = this[--length]; break } } this.length = length }, writable: false},
              splice: {configurable: false, enumerable: false, value: function splice()        { /* ->> Display like an `Array` in the Chrome Dev console */                                                                                                                                                                    }, writable: false}
            });

          // Color
          function Color(red, green, blue, alpha) {
            var value = arguments.length > 1 ?
              ((+blue  % 0x100) << 0x00) |
              ((+green % 0x100) << 0x08) |
              ((+red   % 0x100) << 0x10) |
              (arguments.length > 3 ? ((alpha * 0xFF) % 0x100) << 0x18 : 0xFF000000)
            : arguments.length === 1 ? +arguments[0] : 0x00000000;

            // ...
            Object.defineProperty(this, "blue",    {configurable: false, enumerable: true, get: function() { return (value & 0x000000FF) >>> 0x00          }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0xFFFFFF00) | ((intensity          % 0x100) << 0x00) }});
            Object.defineProperty(this, "green",   {configurable: false, enumerable: true, get: function() { return (value & 0x0000FF00) >>> 0x08          }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0xFFFF00FF) | ((intensity          % 0x100) << 0x08) }});
            Object.defineProperty(this, "red",     {configurable: false, enumerable: true, get: function() { return (value & 0x00FF0000) >>> 0x10          }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0xFF00FFFF) | ((intensity          % 0x100) << 0x10) }});
            Object.defineProperty(this, "alpha",   {configurable: false, enumerable: true, get: function() { return ((value & 0xFF000000) >>> 0x18) / 0xFF }, set: function(intensity) { intensity *= intensity > 0; value = (value & 0x00FFFFFF) | (((intensity * 0xFF) % 0x100) << 0x18) }});
            Object.defineProperty(this, "valueOf", {configurable: false, enumerable: false, value: function valueOf() { return value }, writable: false});

            /* ... */
            Object.preventExtensions(this)
          }
            Color.prototype = Object.freeze(Object.create(null, {
              blue       : {configurable: false, enumerable: true, value: 0x00,  writable: false},
              green      : {configurable: false, enumerable: true, value: 0x00,  writable: false},
              red        : {configurable: false, enumerable: true, value: 0x00,  writable: false},
              alpha      : {configurable: false, enumerable: true, value: 0x00,  writable: false},
              constructor: {configurable: false, enumerable: true, value: Color, writable: false},

              darken  : {configurable: false, enumerable: false, value: function darken  (red, green, blue) { var color = arguments.length === 1 ? new Color(arguments[0]) : new Color(red, green, blue, 0x1); this.blue -= color.blue;                             this.green -= color.green;                              this.red -= color.red;                            return this }, writable: false},
              invert  : {configurable: false, enumerable: false, value: function invert  ()                 {                                                                                                  this.blue  = 0xFF - this.blue;                       this.green  = 0xFF - this.green;                        this.red  = 0xFF - this.red;                      return this }, writable: false},
              lighten : {configurable: false, enumerable: false, value: function lighten (red, green, blue) { var color = arguments.length === 1 ? new Color(arguments[0]) : new Color(red, green, blue, 0x1); this.blue  = Math.min(0xFF, color.blue + this.blue); this.green  = Math.min(0xFF, color.green + this.green); this.red  = Math.min(0xFF, color.red + this.red); return this }, writable: false},
              toString: {configurable: false, enumerable: false, value: function toString()                 { return "rgba(" + this.red + ", " + this.green + ", " + this.blue + ", " + this.alpha + ')'                                                                                                                                                                                  }, writable: false},
              valueOf : {configurable: false, enumerable: false, value: function valueOf ()                 { return (this.alpha << 0x18) | (this.blue << 0x00) | (this.green << 0x08) | (this.red << 0x10)                                                                                                                                                                               }, writable: false}
            }));

            Object.defineProperty(Color, "BLACK",   {configurable: false, enumerable: true, value: new Color(0x00, 0x00, 0x00)});
            Object.defineProperty(Color, "BLUE",    {configurable: false, enumerable: true, value: new Color(0x00, 0x00, 0xFF)});
            Object.defineProperty(Color, "CYAN",    {configurable: false, enumerable: true, value: new Color(0x00, 0xFF, 0xFF)});
            Object.defineProperty(Color, "GRAY",    {configurable: false, enumerable: true, value: new Color(0x69, 0x69, 0x69)});
            Object.defineProperty(Color, "GREEN",   {configurable: false, enumerable: true, value: new Color(0x00, 0xFF, 0x00)});
            Object.defineProperty(Color, "GREY",    {configurable: false, enumerable: true, value: new Color(0x69, 0x69, 0x69)});
            Object.defineProperty(Color, "MAGENTA", {configurable: false, enumerable: true, value: new Color(0xFF, 0x00, 0xFF)});
            Object.defineProperty(Color, "RED",     {configurable: false, enumerable: true, value: new Color(0xFF, 0x00, 0x00)});
            Object.defineProperty(Color, "WHITE",   {configurable: false, enumerable: true, value: new Color(0xFF, 0xFF, 0xFF)});
            Object.defineProperty(Color, "YELLOW",  {configurable: false, enumerable: true, value: new Color(0xFF, 0xFF, 0x00)});

        // Food
        function Food(cell, type) {
          var cell = cell;
          var type = type;

          // ...
          Object.defineProperty(this, "cell", {configurable: false, enumerable: true,  get: function() { return cell }, set: function(object) { cell  = "object" === typeof object && (null === object || object instanceof Cell) ? object : cell }});
          Object.defineProperty(this, "type", {configurable: false, enumerable: true,  get: function() { return type }, set: function(option) { for (var name in Food) if (Food[name] === option) { type = option; break }                        }});

          if (false === ("object" === typeof cell && cell instanceof Cell))
          throw new TypeError("`Food`s must be within a (single) `Cell`");

          this.type = Food.APPLE;
          this.type = type;

          /* ... */
          Object.preventExtensions(this)
        }
          Food.prototype = Object.freeze(Object.create(null, {
            cell       : {configurable: false, enumerable: false, value: null,       writable: false},
            constructor: {configurable: false, enumerable: false, value: Food,       writable: false},
            type       : {configurable: false, enumerable: false, value: Food.APPLE, writable: false},

            board : {configurable: false, enumerable: false, get: function() { return null === this.cell ? null : this.cell.board  }, set: function(board)  { if (null !== this.cell) this.cell.board  = board  }},
            column: {configurable: false, enumerable: false, get: function() { return null === this.cell ? null : this.cell.column }, set: function(column) { if (null !== this.cell) this.cell.column = column }},
            row   : {configurable: false, enumerable: false, get: function() { return null === this.cell ? null : this.cell.row    }, set: function(row)    { if (null !== this.cell) this.cell.row    = row    }}
          }));

          Object.defineProperty(Food, "APPLE",       {configurable: false, enumerable: true, value: 0x01, writable: false});
          Object.defineProperty(Food, "BANANA",      {configurable: false, enumerable: true, value: 0x02, writable: false});
          Object.defineProperty(Food, "BLUEBERRIES", {configurable: false, enumerable: true, value: 0x03, writable: false});
          Object.defineProperty(Food, "CHERRIES",    {configurable: false, enumerable: true, value: 0x04, writable: false});
          Object.defineProperty(Food, "COCONUT",     {configurable: false, enumerable: true, value: 0x05, writable: false});
          Object.defineProperty(Food, "GRAPES",      {configurable: false, enumerable: true, value: 0x06, writable: false});
          Object.defineProperty(Food, "KIWI",        {configurable: false, enumerable: true, value: 0x07, writable: false});
          Object.defineProperty(Food, "MANGO",       {configurable: false, enumerable: true, value: 0x08, writable: false});
          Object.defineProperty(Food, "MELON",       {configurable: false, enumerable: true, value: 0x09, writable: false});
          Object.defineProperty(Food, "LEMON",       {configurable: false, enumerable: true, value: 0x0A, writable: false});
          Object.defineProperty(Food, "OLIVE",       {configurable: false, enumerable: true, value: 0x0B, writable: false});
          Object.defineProperty(Food, "PEACH",       {configurable: false, enumerable: true, value: 0x0C, writable: false});
          Object.defineProperty(Food, "PEAR",        {configurable: false, enumerable: true, value: 0x0D, writable: false});
          Object.defineProperty(Food, "PINEAPPLE",   {configurable: false, enumerable: true, value: 0x0E, writable: false});
          Object.defineProperty(Food, "ORANGE",      {configurable: false, enumerable: true, value: 0x0F, writable: false});
          Object.defineProperty(Food, "STRAWBERRY",  {configurable: false, enumerable: true, value: 0x10, writable: false});
          Object.defineProperty(Food, "TANGERINE",   {configurable: false, enumerable: true, value: 0x11, writable: false});
          Object.defineProperty(Food, "TOMATO",      {configurable: false, enumerable: true, value: 0x12, writable: false});
          Object.defineProperty(Food, "WATERMELON",  {configurable: false, enumerable: true, value: 0x13, writable: false});

          Object.defineProperty(Food, "BADGER",   {configurable: false, enumerable: true, value: 0x14, writable: false});
          Object.defineProperty(Food, "CAMEL",    {configurable: false, enumerable: true, value: 0x15, writable: false});
          Object.defineProperty(Food, "CAT",      {configurable: false, enumerable: true, value: 0x16, writable: false});
          Object.defineProperty(Food, "CHIPMUNK", {configurable: false, enumerable: true, value: 0x17, writable: false});
          Object.defineProperty(Food, "COW",      {configurable: false, enumerable: true, value: 0x18, writable: false});
          Object.defineProperty(Food, "DOG",      {configurable: false, enumerable: true, value: 0x19, writable: false});
          Object.defineProperty(Food, "GIRAFFE",  {configurable: false, enumerable: true, value: 0x1A, writable: false});
          Object.defineProperty(Food, "GOAT",     {configurable: false, enumerable: true, value: 0x1B, writable: false});
          Object.defineProperty(Food, "HORSE",    {configurable: false, enumerable: true, value: 0x1C, writable: false});
          Object.defineProperty(Food, "MONKEY",   {configurable: false, enumerable: true, value: 0x1D, writable: false});
          Object.defineProperty(Food, "MOUSE",    {configurable: false, enumerable: true, value: 0x1E, writable: false});
          Object.defineProperty(Food, "PIG",      {configurable: false, enumerable: true, value: 0x1F, writable: false});
          Object.defineProperty(Food, "RABBIT",   {configurable: false, enumerable: true, value: 0x20, writable: false});
          Object.defineProperty(Food, "RACCOON",  {configurable: false, enumerable: true, value: 0x21, writable: false});
          Object.defineProperty(Food, "RAM",      {configurable: false, enumerable: true, value: 0x22, writable: false});
          Object.defineProperty(Food, "RAT",      {configurable: false, enumerable: true, value: 0x23, writable: false});
          Object.defineProperty(Food, "SHEEP",    {configurable: false, enumerable: true, value: 0x24, writable: false});
          Object.defineProperty(Food, "SLOTH",    {configurable: false, enumerable: true, value: 0x25, writable: false});
          Object.defineProperty(Food, "ZEBRA",    {configurable: false, enumerable: true, value: 0x26, writable: false});

          Object.preventExtensions(Food);

        // Snake
        function Snake(head) {
          var direction      = Snake.prototype.direction;
          var head           = head;
          var headColor      = new Color(Snake.prototype.headColor);
          var tailColor      = new Color(Snake.prototype.tailColor);
          var tailCollection = new Collection();

          // ...
          Object.defineProperty(this, "board",     {configurable: false, enumerable: false, get: function() { return head.board     }, set: function(board)      { head.board = board                                                                                                                                                                                                              }});
          Object.defineProperty(this, "direction", {configurable: false, enumerable: false, get: function() { return direction      }, set: function(option)     { switch (option) { case 0x0: case Snake.DOWN: case Snake.LEFT: case Snake.RIGHT: case Snake.UP: direction = option }                                                                                                             }});
          Object.defineProperty(this, "head",      {configurable: false, enumerable: false, get: function() { return head           }, set: function(cell)       { if ("object" !== typeof cell) return; if (null === cell) { head = null; tailCollection = new Collection() } else if (cell instanceof Cell) { cell.owner = this; head = cell; tailCollection = new Collection(cell.board.size) } }});
          Object.defineProperty(this, "headColor", {configurable: false, enumerable: false, get: function() { return headColor      }, set: function(color)      { headColor      = new Color(color)                                                                                                                                                                                               }});
          Object.defineProperty(this, "tail",      {configurable: false, enumerable: false, get: function() { return tailCollection }, set: function(collection) { tailCollection = "object" === typeof collection && collection instanceof Collection ? collection : tailCollection                                                                                                               }});
          Object.defineProperty(this, "tailColor", {configurable: false, enumerable: false, get: function() { return tailColor      }, set: function(color)      { tailColor      = new Color(color)                                                                                                                                                                                               }});

          if (false === ("object" === typeof head && head instanceof Cell))
          throw new TypeError("`Snake`s must have a (single) `Cell` head");

          /* ... */
          Object.preventExtensions(this)
        }
          Snake.prototype = Object.freeze(Object.create(null, {
            board      : {configurable: false, enumerable: false, value: null,             writable: false},
            constructor: {configurable: false, enumerable: false, value: Snake,            writable: false},
            direction  : {configurable: false, enumerable: false, value: 0x0,              writable: false},
            head       : {configurable: false, enumerable: false, value: null,             writable: false},
            headColor  : {configurable: false, enumerable: false, value: Color.GREY,       writable: false},
            tail       : {configurable: false, enumerable: false, value: new Collection(), writable: false},
            tailColor  : {configurable: false, enumerable: false, value: Color.BLACK,      writable: false}
          }));

          Object.defineProperty(Snake, "DOWN",  {configurable: false, enumerable: false, value: 0x1, writable: false});
          Object.defineProperty(Snake, "LEFT",  {configurable: false, enumerable: false, value: 0x2, writable: false});
          Object.defineProperty(Snake, "RIGHT", {configurable: false, enumerable: false, value: 0x3, writable: false});
          Object.defineProperty(Snake, "UP",    {configurable: false, enumerable: false, value: 0x4, writable: false});

          Object.preventExtensions(Snake);

        // Board
        function Board(context) {
          var BOARD  = this;
          var MEATS  = [Food.BADGER, Food.CAMEL, Food.CAT, Food.CHIPMUNK, Food.COW, Food.DOG, Food.GIRAFFE, Food.GOAT, Food.HORSE, Food.MONKEY, Food.MOUSE, Food.PIG, Food.RABBIT, Food.RACCOON, Food.RAM, Food.RAT, Food.SHEEP, Food.SLOTH, Food.ZEBRA];
          var PLANTS = [Food.APPLE, Food.BANANA, Food.BLUEBERRIES, Food.CHERRIES, Food.COCONUT, Food.GRAPES, Food.KIWI, Food.MANGO, Food.MELON, Food.LEMON, Food.OLIVE, Food.PEACH, Food.PEAR, Food.PINEAPPLE, Food.ORANGE, Food.STRAWBERRY, Food.TANGERINE, Food.TOMATO, Food.WATERMELON];

          var alias                 = coordinate => coordinate | 0; // ->> reduce non-intentioned anti-aliasing
          var aliasSVGElement       = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          var aliasSVGFilterID      = "alias";
          var aliasSVGURL           = null;
          var backgroundColor       = new Color(Board.prototype.backgroundColor);
          var boardCanvas           = null;
          var boardContext          = context;
          var boardMargin           = Board.prototype.boardMargin;
          var boardPadding          = Board.prototype.boardPadding;
          var boardRadius           = Board.prototype.boardRadius;
          var canvas                = document.createElement("canvas");
          var cellMargin            = Board.prototype.cellMargin;
          var cellRadius            = Board.prototype.cellRadius;
          var columnCount           = Board.prototype.columnCount;
          var context               = canvas.getContext("2d", {alpha: true, desynchronized: true});
          var food                  = new Collection(0);
          var foodMaximumCount      = Board.prototype.foodMaximumCount;
          var foodSpawnDelta        = Board.prototype.foodSpawnDelta;
          var foodSpawnMinimumCount = Board.prototype.foodSpawnMinimumCount;
          var foodSpawnTimer        = Board.prototype.foodSpawnTimer;
          var foodSpawnTimestamp    = new Date();
          var foregroundColor       = new Color(Board.prototype.foregroundColor);
          var rowCount              = Board.prototype.rowCount;
          var snakeMaximumCount     = 0;
          var snakes                = new Collection(1);
          var vegan                 = Board.prototype.vegan;
          var walls                 = new Collection(0);
          var zoom                  = 1.0;

          // ...
          function getBoardClientSize() {
            return Math.max(0.0, Math.min(canvas.height, canvas.width) - (boardMargin * 2.0))
          }

          function getCellClientSize(size) {
            return (size - (boardPadding * 2.0) - (boardRadius * 2.0)) / (columnCount > rowCount ? columnCount : rowCount)
          }

          function getClientZoom() {
            var zoom = devicePixelRatio;

            // ...
            for (var node = boardCanvas; node.type === 0x1 /* --> Node.ELEMENT_NODE */; node = node.parentNode)
            zoom *= (getComputedStyle(node) /* ->> preferably cached */).getPropertyValue("zoom");

            return zoom
          }

          function realias() {
            if (null !== aliasSVGURL) URL.revokeObjectURL(aliasSVGURL);
            aliasSVGURL = URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(aliasSVGElement)], {type: "image/svg+xml"}))
          }

          function resize() {
            var recentFood   = food;
            var recentSnakes = snakes;
            var recentWalls  = walls;
            var size         = BOARD.size;
            var snakeCount   = (() => { var count = snakes.length; for (var index = count; index; ) count += snakes[--index].tail.length; return count })();
            var wallCount    = walls.length;

            // ...
            realias();

            food   = new Collection(Math.min(foodMaximumCount, size - (snakeCount + wallCount)));
            walls  = new Collection(BOARD.size);
            snakes = size > snakeMaximumCount ? new Collection(snakeMaximumCount = size) : snakes;

            for (var index = recentFood  .length; index--; ) { if (columnCount > recentFood[index].column && rowCount > recentFood[index].row)         food  .add(recentFood  [index]) }
            for (var index = recentWalls .length; index--; ) { /* if (columnCount > recentWalls[index].column && rowCount > recentWalls[index].row) */ walls .add(recentWalls [index]) }
            for (var index = recentSnakes.length; index--; ) { if (recentSnakes === snakes) break;                                                     snakes.add(recentSnakes[index]) }

            for (var index = snakes.length; index; ) {
              var snake = snakes[--index];

              if (columnCount <= snake.head.column || rowCount <= snake.head.row) {
                snakes.remove(snake);
                snake.tail.length = 0;

                walls.add(new Wall(BOARD, snake.head))
              }
            }

            if (0 === snakes.length)
            BOARD.spawn() // UPDATE (Lapys)
          }

          // ...
          Object.defineProperty(this, "backgroundColor", {configurable: false, enumerable: false, get: function() { return backgroundColor }, set: function(color) { backgroundColor = new Color(color) }});
          Object.defineProperty(this, "foregroundColor", {configurable: false, enumerable: false, get: function() { return foregroundColor }, set: function(color) { foregroundColor = new Color(color) }});

          Object.defineProperty(this, "boardMargin",           {configurable: false, enumerable: false, get: function() { return boardMargin           }, set: function(margin)       { boardMargin           = +margin;           boardMargin          *= boardMargin    > 0                                                                }});
          Object.defineProperty(this, "boardPadding",          {configurable: false, enumerable: false, get: function() { return boardPadding          }, set: function(padding)      { boardPadding          = +padding;          boardPadding         *= boardPadding   > 0                                                                }});
          Object.defineProperty(this, "boardRadius",           {configurable: false, enumerable: false, get: function() { return boardRadius           }, set: function(radius)       { boardRadius           = +radius;           boardRadius          *= boardRadius    > 0                                                                }});
          Object.defineProperty(this, "cellMargin",            {configurable: false, enumerable: false, get: function() { return cellMargin            }, set: function(margin)       { cellMargin            = +margin;           cellMargin           *= cellMargin     > 0                                                                }});
          Object.defineProperty(this, "cellRadius",            {configurable: false, enumerable: false, get: function() { return cellRadius            }, set: function(radius)       { cellRadius            = +radius;           cellRadius           *= cellRadius     > 0                                                                }});
          Object.defineProperty(this, "columnCount",           {configurable: false, enumerable: false, get: function() { return columnCount           }, set: function(count)        { columnCount           = +count        | 0; columnCount          *= columnCount    > 0; this.foodMaximumCount = Math.min(foodMaximumCount, this.size) }});
          Object.defineProperty(this, "foodSpawnDelta",        {configurable: false, enumerable: false, get: function() { return foodSpawnDelta        }, set: function(delta)        { foodSpawnDelta        = +delta        | 0; foodSpawnDelta       *= foodSpawnDelta > 0                                                                }});
          Object.defineProperty(this, "foodSpawnMinimumCount", {configurable: false, enumerable: false, get: function() { return foodSpawnMinimumCount }, set: function(count)        { foodSpawnMinimumCount = +count        | 0; foodSpawnMinimumCount = foodSpawnMinimumCount > 1 ? foodSpawnMinimumCount : 1                             }});
          Object.defineProperty(this, "foodSpawnTimer",        {configurable: false, enumerable: false, get: function() { return foodSpawnTimer        }, set: function(milliseconds) { foodSpawnTimer        = +milliseconds | 0; foodSpawnTimer       *= foodSpawnTimer > 0                                                                }});
          Object.defineProperty(this, "rowCount",              {configurable: false, enumerable: false, get: function() { return rowCount              }, set: function(count)        { rowCount              = +count        | 0; rowCount             *= rowCount       > 0; this.foodMaximumCount = Math.min(foodMaximumCount, this.size) }});
          Object.defineProperty(this, "vegan",                 {configurable: false, enumerable: false, get: function() { return vegan                 }, set: function(boolean)      { vegan                 = !!boolean                                                                                                                    }});

          Object.defineProperty(this, "context",          {configurable: false, enumerable: false, get: function() { return boardContext     }, set: function(object) { if ("object" === typeof object && (object instanceof CanvasRenderingContext2D || object instanceof OffscreenCanvasRenderingContext2D)) { boardCanvas = object.canvas; boardContext = object } }});
          Object.defineProperty(this, "foodMaximumCount", {configurable: false, enumerable: false, get: function() { return foodMaximumCount }, set: function(count)  { var recentFoodMaximumCount = foodMaximumCount; foodMaximumCount = +count | 0; foodMaximumCount *= foodMaximumCount > 0; if (foodMaximumCount !== recentFoodMaximumCount) resize()             }});

          Object.defineProperty(this, "boardSize", {configurable: false, enumerable: false, get: function() { return getBoardClientSize()                    }});
          Object.defineProperty(this, "cellSize",  {configurable: false, enumerable: false, get: function() { return getCellClientSize(getBoardClientSize()) }});
          Object.defineProperty(this, "food",      {configurable: false, enumerable: false, get: function() { return food                                    }});
          Object.defineProperty(this, "snakes",    {configurable: false, enumerable: false, get: function() { return snakes                                  }});
          Object.defineProperty(this, "walls",     {configurable: false, enumerable: false, get: function() { return walls                                   }});

          if (false === ("object" === typeof context && (context instanceof CanvasRenderingContext2D || context instanceof OffscreenCanvasRenderingContext2D)))
          throw TypeError("`Board` requires a valid `HTMLCanvasElement` \"2d\" context");

          boardCanvas = boardContext.canvas;

          this.spawn();
          aliasSVGElement
            .appendChild(document.createElementNS("http://www.w3.org/2000/svg", "defs"))
            .appendChild((filter => {
              filter.id = aliasSVGFilterID;
              filter.setAttributeNS(null, "height", "100%");
              filter.setAttributeNS(null, "width", "100%");
              filter.setAttributeNS(null, 'x', 0);
              filter.setAttributeNS(null, 'y', 0);

              return filter
            })(document.createElementNS("http://www.w3.org/2000/svg", "filter")))
            .appendChild(document.createElementNS("http://www.w3.org/2000/svg", "feComponentTransfer"))
            .appendChild((filterElementFunctionAlpha => {
              filterElementFunctionAlpha.setAttributeNS(null, "tableValues", "0 1");
              filterElementFunctionAlpha.setAttributeNS(null, "type", "discrete");

              return filterElementFunctionAlpha
            })(document.createElementNS("http://www.w3.org/2000/svg", "feFuncA")));

          // ...
          requestAnimationFrame(function render() {
            var zoom                          = getClientZoom();
            var boardCanvasBoundingClientRect = boardCanvas.getBoundingClientRect();
            var boardContextFilter            = boardContext.filter;
            var boardSize                     = getBoardClientSize();
            var boardTop                      = ((boardCanvasBoundingClientRect.height * zoom) - boardSize) / 2.0;
            var boardLeft                     = ((boardCanvasBoundingClientRect.width  * zoom) - boardSize) / 2.0;
            var cellSize                      = getCellClientSize(boardSize);
            var cellLeft                      = boardLeft + boardRadius + boardPadding + ((cellMargin < cellSize ? cellMargin : cellSize) / 2.0) + (((boardSize - (boardPadding * 2.0) - (boardRadius * 2.0)) - (columnCount * cellSize)) / 2.0);
            var cellTop                       = boardTop  + boardRadius + boardPadding + ((cellMargin < cellSize ? cellMargin : cellSize) / 2.0) + (((boardSize - (boardPadding * 2.0) - (boardRadius * 2.0)) - (rowCount    * cellSize)) / 2.0);
            var foodCount                     = food.length;
            var foodSpawnIncoming             = foodCount < foodSpawnMinimumCount;
            var size                          = BOARD.size;
            var snakeCount                    = (() => { var count = snakes.length; for (var index = count; index; ) count += snakes[--index].tail.length; return count })();
            var wallCount                     = walls.length;

            // Modification > ...
            if (null === aliasSVGURL) realias();

            boardCanvas.height            = boardCanvasBoundingClientRect.height * zoom;
            boardCanvas.width             = boardCanvasBoundingClientRect.width  * zoom;
            canvas.height                 = alias(boardCanvas.height);
            canvas.width                  = alias(boardCanvas.width);
            context.font                  = (getComputedStyle(boardCanvas) /* ->> preferably cached */).getPropertyValue("font-size") + " monospace";
            context.imageSmoothingEnabled = false;
            context.imageSmoothingQuality = "low";

            aliasSVGElement.setAttributeNS(null, "height", "0px");
            aliasSVGElement.setAttributeNS(null, "width", "0px");
            context.clearRect(0, 0, canvas.width, canvas.height);

            // ... [Board]
            context.fillStyle = backgroundColor;

            context.beginPath();
              context.arc(alias(boardLeft + boardRadius + (boardSize * 0)), alias(boardTop + boardRadius + (boardSize * 0)), alias(boardRadius), Math.PI * 0.0, Math.PI * 2.0);
              context.arc(alias(boardLeft - boardRadius + (boardSize * 1)), alias(boardTop + boardRadius + (boardSize * 0)), alias(boardRadius), Math.PI * 0.0, Math.PI * 2.0);

              context.fill();
            context.closePath();

            context.beginPath();
              context.arc(alias(boardLeft - boardRadius + (boardSize * 1)), alias(boardTop - boardRadius + (boardSize * 1)), boardRadius, Math.PI * 0.0, Math.PI * 2.0);
              context.arc(alias(boardLeft + boardRadius + (boardSize * 0)), alias(boardTop - boardRadius + (boardSize * 1)), boardRadius, Math.PI * 0.0, Math.PI * 2.0);

              context.fill();
            context.closePath();

            context.fillRect(alias(boardLeft - (boardRadius * 0.0) + (boardSize * 0)), alias(boardTop + (boardRadius * 1.0) + (boardSize * 0)), alias(boardRadius * 2.0), alias(boardSize - (boardRadius * 2.0)));
            context.fillRect(alias(boardLeft - (boardRadius * 2.0) + (boardSize * 1)), alias(boardTop + (boardRadius * 1.0) + (boardSize * 0)), alias(boardRadius * 2.0), alias(boardSize - (boardRadius * 2.0)));
            context.fillRect(alias(boardLeft + (boardRadius * 1.0) + (boardSize * 0)), alias(boardTop - (boardRadius * 0.0) + (boardSize * 0)), alias(boardSize - (boardRadius * 2.0)), alias(boardRadius * 2.0));
            context.fillRect(alias(boardLeft + (boardRadius * 1.0) + (boardSize * 0)), alias(boardTop - (boardRadius * 2.0) + (boardSize * 1)), alias(boardSize - (boardRadius * 2.0)), alias(boardRadius * 2.0));

            context.fillRect(alias(boardLeft + (boardRadius * 1.0)), alias(boardTop + (boardRadius * 1.0)), alias(boardSize - (boardRadius * 2.0)), alias(boardSize - (boardRadius * 2.0)));

            // ... [Food]
            foodSpawnIncoming  = foodSpawnIncoming || foodSpawnTimer < new Date() - foodSpawnTimestamp;
            foodSpawnTimestamp = foodSpawnIncoming ? new Date() : foodSpawnTimestamp;

            if (foodSpawnIncoming && foodCount < Math.min(foodMaximumCount, size - (snakeCount + wallCount))) {
              if (foodCount > foodSpawnMinimumCount + foodSpawnDelta)
                food.length = foodSpawnMinimumCount + foodSpawnDelta;

              while (foodCount < foodSpawnMinimumCount + Math.trunc(Math.random() * foodSpawnDelta)) {
                var column = 0;
                var row    = 0;

                // ...
                generate_coordinates:
                while (true) {
                  column = Math.trunc(columnCount * Math.random());
                  row    = Math.trunc(rowCount    * Math.random());

                  // ...
                  for (var index = foodCount; index--; ) {
                    if (column === food[index].column && row === food[index].row)
                    continue generate_coordinates
                  }

                  for (var index = wallCount; index--; ) {
                    if (column === walls[index].column && row === walls[index].row)
                    continue generate_coordinates
                  }

                  for (var index = snakes.length; index--; ) {
                    if (column === snakes[index].head.column && row === snakes[index].head.row)
                    continue generate_coordinates;

                    for (var subindex = snakes[index].tail.length; subindex--; ) {
                      if (column === snakes[index].tail[subindex].column && row === snakes[index].tail[subindex].row)
                      continue generate_coordinates
                    }
                  }

                  break
                }

                if (false === food.add(new Food(new Cell(BOARD, column, row), (vegan ? PLANTS : MEATS)[Math.trunc(Math.random() * (vegan ? PLANTS : MEATS).length)]))) break;
                if (++foodCount === Math.min(foodMaximumCount, size - (snakeCount + wallCount))) break
              }
            }

            // ... [Cell]
            for (var row = rowCount; row--; )
            for (var column = columnCount; column--; ) {
              var size              = cellSize - (cellMargin < cellSize ? cellMargin : cellSize);
              var topLeftRadius     = Math.min(size / 2.0, column === 0               && row === 0            ? Math.max(boardRadius, cellRadius) : cellRadius);
              var topRightRadius    = Math.min(size / 2.0, column === columnCount - 1 && row === 0            ? Math.max(boardRadius, cellRadius) : cellRadius);
              var left              = cellLeft + (column * cellSize);
              var top               = cellTop  + (row    * cellSize);
              var bottomLeftRadius  = Math.min(size / 2.0, column === 0               && row === rowCount - 1 ? Math.max(boardRadius, cellRadius) : cellRadius);
              var bottomRightRadius = Math.min(size / 2.0, column === columnCount - 1 && row === rowCount - 1 ? Math.max(boardRadius, cellRadius) : cellRadius);

              // ...
              context.fillStyle = (column + row) % 2 ? new Color(foregroundColor).darken(0x19, 0x19, 0x19) : foregroundColor;

              generate_food_color:
              for (var index = food.length; index--; )
              if (column === food[index].column && row === food[index].row) {
                context.fillStyle = new Color(foregroundColor).lighten(0x99, 0x33, 0x00).darken(0x33, 0x33, 0x66);
                break generate_food_color
              }

              generate_wall_color:
              for (var index = walls.length; index--; )
              if (column === walls[index].column && row === walls[index].row) {
                context.fillStyle = new Color(backgroundColor).darken(0x1F, 0x1F, 0x1F);
                context.fillRect(alias(left) - ((cellMargin < cellSize ? cellMargin : cellSize) / 2.0), alias(top) - ((cellMargin < cellSize ? cellMargin : cellSize) / 2.0), alias(cellSize), alias(cellSize));

                break generate_wall_color
              }

              // generate_snake_color:
              // for (var index = snakes.length; index--; ) {
              //   for (var subindex = snakes[index].tail.length; subindex--; )
              //   if (column === snakes[index].tail[subindex].column && row === snakes[index].tail[subindex].row) {
              //     context.fillStyle = snakes[index].tailColor;
              //     break generate_snake_color
              //   }

              //   if (column === snakes[index].head.column && row === snakes[index].head.row) {
              //     context.fillStyle = snakes[index].headColor;
              //     break generate_snake_color
              //   }
              // }

              context.beginPath();
                context.arc(alias(left + topLeftRadius  + (size * 0)), alias(top + topLeftRadius  + (size * 0)), alias(topLeftRadius),  Math.PI * 0.0, Math.PI * 2.0);
                context.arc(alias(left - topRightRadius + (size * 1)), alias(top + topRightRadius + (size * 0)), alias(topRightRadius), Math.PI * 0.0, Math.PI * 2.0);

                context.fill();
              context.closePath();

              context.beginPath();
                context.arc(alias(left - bottomRightRadius + (size * 1)), alias(top - bottomRightRadius + (size * 1)), alias(bottomRightRadius), Math.PI * 0.0, Math.PI * 2.0);
                context.arc(alias(left + bottomLeftRadius  + (size * 0)), alias(top - bottomLeftRadius  + (size * 1)), alias(bottomLeftRadius),  Math.PI * 0.0, Math.PI * 2.0);

                context.fill();
              context.closePath();

              context.fillRect(alias(left - (Math.max(cellRadius, topLeftRadius)    * 0.0) + (size * 0)), alias(top + (Math.max(cellRadius, topLeftRadius)    * 1.0) + (size * 0)), alias(cellRadius * 2.0), alias(size - (bottomLeftRadius  + topLeftRadius)));
              context.fillRect(alias(left - (Math.min(cellRadius, topRightRadius)   * 2.0) + (size * 1)), alias(top + (Math.max(cellRadius, topRightRadius)   * 1.0) + (size * 0)), alias(cellRadius * 2.0), alias(size - (bottomRightRadius + topRightRadius)));
              context.fillRect(alias(left + (Math.max(cellRadius, topLeftRadius)    * 1.0) + (size * 0)), alias(top - (Math.max(cellRadius, topLeftRadius)    * 0.0) + (size * 0)), alias(size - (topLeftRadius    + topRightRadius)),    alias(cellRadius * 2.0));
              context.fillRect(alias(left + (Math.max(cellRadius, bottomLeftRadius) * 1.0) + (size * 0)), alias(top - (Math.min(cellRadius, bottomLeftRadius) * 2.0) + (size * 1)), alias(size - (bottomLeftRadius + bottomRightRadius)), alias(cellRadius * 2.0));

              context.fillRect(alias(left + (cellRadius * 1.0)), alias(top + (cellRadius * 1.0)), alias(size - (cellRadius * 2.0)), alias(size - (cellRadius * 2.0)))
            }

            // ... [Snake]
            for (var index = snakes.length; index; ) {
              var snake     = snakes[--index];
              var snakeHead = snake.head;
              var snakeTail = snake.tail;

              var snakeLeft = cellLeft - ((cellMargin < cellSize ? cellMargin : cellSize) / 2.0);
              var snakeTop  = cellTop  - ((cellMargin < cellSize ? cellMargin : cellSize) / 2.0);
              var left      = snakeLeft + (snakeHead.column * cellSize);
              var top       = snakeTop  + (snakeHead.row    * cellSize);

              // ... [Snake Head]
              context.fillStyle = snake.headColor;

              context.beginPath();
                context.arc(alias(left + (cellSize / 2.0)), alias(top + (cellSize / 2.0)), alias(cellSize / 2.0), Math.PI * 0.0, Math.PI * 2.0);
                context.fill();
              context.closePath();

              // // ... [Snake Tail]
              // for (var subindex = snakeTail.length; subindex--; )
              // snakeTail[subindex]
            }

            // ... [Context Menu]

            // ...
            boardContext.filter = "url(\"" + aliasSVGURL + '#' + aliasSVGFilterID + "\")";
            boardContext.drawImage(canvas, 0, 0, boardCanvas.width, boardCanvas.height);
            boardContext.filter = boardContextFilter;

            /* ... */
            requestAnimationFrame(render)
          });

          /* ... */
          Object.preventExtensions(this)
        }
          Board.prototype = Object.freeze(Object.create(null, {
            backgroundColor      : {configurable: false, enumerable: false, value: Color.GREY,       writable: false},
            boardMargin          : {configurable: false, enumerable: false, value: 0,                writable: false},
            boardPadding         : {configurable: false, enumerable: false, value: 0,                writable: false},
            boardRadius          : {configurable: false, enumerable: false, value: 0,                writable: false},
            boardSize            : {configurable: false, enumerable: false, value: 0,                writable: false},
            cellMargin           : {configurable: false, enumerable: false, value: 1,                writable: false},
            cellRadius           : {configurable: false, enumerable: false, value: 0,                writable: false},
            cellSize             : {configurable: false, enumerable: false, value: 0,                writable: false},
            columnCount          : {configurable: false, enumerable: false, value: 1,                writable: false},
            constructor          : {configurable: false, enumerable: false, value: Board,            writable: false},
            context              : {configurable: false, enumerable: false, value: null,             writable: false},
            food                 : {configurable: false, enumerable: false, value: new Collection(), writable: false},
            foodMaximumCount     : {configurable: false, enumerable: false, value: 1,                writable: false},
            foodSpawnDelta       : {configurable: false, enumerable: false, value: 0,                writable: false},
            foodSpawnMinimumCount: {configurable: false, enumerable: false, value: 1,                writable: false},
            foodSpawnTimer       : {configurable: false, enumerable: false, value: 3000,             writable: false},
            foregroundColor      : {configurable: false, enumerable: false, value: Color.WHITE,      writable: false},
            rowCount             : {configurable: false, enumerable: false, value: 1,                writable: false},
            snakes               : {configurable: false, enumerable: false, value: new Collection(), writable: false},
            vegan                : {configurable: false, enumerable: false, value: true,             writable: false},
            walls                : {configurable: false, enumerable: false, value: new Collection(), writable: false},

            size: {configurable: false, enumerable: false, get: function() { return this.columnCount * this.rowCount }},

            spawn: {configurable: false, enumerable: false, value: function spawn() {
              var food       = this.food;
              var foodCount  = food.length;
              var column     = -1;
              var row        = -1;
              var snake      = new Snake(new SnakeHead(this));
              var snakes     = this.snakes;
              var snakeCount = (() => { var count = snakes.length; for (var index = count; index; ) count += snakes[--index].tail.length; return count })();
              var walls      = this.walls;
              var wallCount  = walls.length;

              // ...
              if (this.size <= foodCount + snakeCount + wallCount)
              return false;

              generate_coordinates:
              while (true) {
                column = column !== -1 ? Math.trunc(this.columnCount * Math.random()) : Math.trunc(this.columnCount / 2);
                row    = row    !== -1 ? Math.trunc(this.rowCount    * Math.random()) : Math.trunc(this.rowCount    / 2);

                for (var index = food.length; index--; ) {
                  if (column === food[index].column && row === food[index].row)
                  continue generate_coordinates
                }

                for (var index = walls.length; index--; ) {
                  if (column === walls[index].column && row === walls[index].row)
                  continue generate_coordinates
                }

                for (var index = snakes.length; index--; ) {
                  if (column === snakes[index].head.column && row === snakes[index].head.row)
                  continue generate_coordinates;

                  for (var subindex = snakes[index].tail.length; subindex--; ) {
                    if (column === snakes[index].tail[subindex].column && row === snakes[index].tail[subindex].row)
                    continue generate_coordinates
                  }
                }

                break
              }

              if (snakes.add(snake)) {
                snake.head.column = column;
                snake.head.row    = row;
                snake.headColor   = new Color(Math.trunc(Math.random() * 0xFF), Math.trunc(Math.random() * 0xFF), Math.trunc(Math.random() * 0xFF));
                snake.tailColor   = new Color(snake.headColor).darken(0x13, 0x13, 0x13);

                return true
              }

              return false
            }, writable: false}
          }));

        /* Constant > ... */
        var BOARD = new Board((canvas instanceof HTMLCanvasElement ? canvas : document.createElement("canvas")).getContext("2d", {alpha: true, desynchronized: true}));

        /* Modification > ... */
        BOARD.backgroundColor       = new Color(0x66, 0x66, 0x66);
        BOARD.cellRadius            = 5.0;
        BOARD.columnCount           = 15;
        BOARD.foodMaximumCount      = 3;
        BOARD.foodSpawnDelta        = 2;
        BOARD.foregroundColor       = new Color(0x99, 0x99, 0x99);
        BOARD.rowCount              = 10;
        BOARD.snakes[0].head.column = Math.trunc(BOARD.columnCount / 2);
        BOARD.snakes[0].head.row    = Math.trunc(BOARD.rowCount    / 2);
        BOARD.snakes[0].headColor   = new Color(0x00, 0x96, 0xFF);
        BOARD.snakes[0].tailColor   = new Color(0x00, 0x69, 0xFF);
        BOARD.vegan                 = true;

        /* ... */
        setTimeout(function render() {
          var boardSize = BOARD.boardSize;

          // ...
          BOARD.boardMargin           = boardSize * (3.0025 / 100.0);
          BOARD.boardPadding          = 8;
          BOARD.boardRadius           = boardSize * (3.0050 / 100.0);
          BOARD.cellMargin            = boardSize * (1.0125 / 100.0);
          BOARD.cellRadius            = boardSize * (1.0625 / 100.0);
          BOARD.foodSpawnDelta        = BOARD.snakes.length + 2;
          BOARD.foodSpawnMinimumCount = BOARD.snakes.length + 1;

          /* ... */
          requestAnimationFrame(render)
        }, 1)
      } catch (error) { throw error; try { null() } catch (error) {
        error.message = "Fix your JavaScript! \uD83D\uDC0D";
        throw error
      } };
    </script>
  </body>
</html>
